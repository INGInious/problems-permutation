{"version":3,"sources":["webpack://PermutationTaskUI/webpack/bootstrap","webpack://PermutationTaskUI/./node_modules/muuri/muuri.js","webpack://PermutationTaskUI/./node_modules/hammerjs/hammer.js","webpack://PermutationTaskUI/./src/IdManager.jsx","webpack://PermutationTaskUI/./src/GridSystem.jsx","webpack://PermutationTaskUI/./src/index.jsx","webpack://PermutationTaskUI/(webpack)/buildin/module.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","factory","Hammer","_typeof","e","__WEBPACK_AMD_DEFINE_ARRAY__","undefined","__WEBPACK_AMD_DEFINE_RESULT__","apply","window","namespace","fn","Array","Math","Error","Element","doc","document","docElem","documentElement","body","typeFunction","typeString","typeNumber","rafLoop","nextTick","queue","map","raf","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","bind","flush","maxBatchSize","Grid","_maxRafBatchSize","batch","splice","min","length","batchMap","add","type","id","readCallback","writeCallback","currentIndex","indexOf","rafQueueMove","rafQueueScroll","unshift","push","cancel","createRafLoop","rafQueueVisibility","startPredicateInactive","startPredicatePending","startPredicateResolved","startPredicateRejected","gridInstances","itemInstances","noop","uuid","elementMatches","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","el","selector","transform","style","prefix","propName","styleCap","charAt","toUpperCase","slice","prefixes","toLowerCase","styleName","getSupportedStyle","transformLeaksFixed","doesTransformLeakFixed","evLayoutEnd","evShowStart","evShowEnd","evHideStart","evHideEnd","element","options","settings","items","layoutOnResize","defaultSettings","userSettings","ret","inst","this","_element","querySelector","contains","_settings","defaultOptions","mergeObjects","visibleStyles","hiddenStyles","dragSort","_id","_isDestroyed","_layout","_emitter","Emitter","_itemShowHandler","getItemVisibilityHandler","_itemHideHandler","addClass","containerClass","_items","nodeListToArray","children","forEach","itemElement","Item","isArray","isNodeList","addEventListener","_resizeHandler","debounce","refreshItems","layout","layoutOnInit","grid","isHidden","parentNode","appendChild","itemClass","getStyle","itemHiddenClass","itemVisibleClass","_gridId","_child","_animate","ItemAnimate","_animateChild","_isActive","_isPositioning","_isHidden","_isHiding","_isShowing","_visibilityQueue","_layoutQueue","_left","_top","setStyles","left","top","getTranslateString","display","_refreshDimensions","_refreshSortData","start","_migrate","ItemMigrate","_release","ItemRelease","_drag","dragEnabled","ItemDrag","_events","item","_item","_animation","_propsTo","_itemId","isActive","container","containerDiffX","containerDiffY","isPositioningStarted","hammer","startPredicateResult","drag","getGrid","startPredicate","dragStartPredicate","defaultStartPredicate","startPredicateState","_hammer","Manager","_isMigrating","_data","_resolveStartPredicate","event","onStart","_scrollListener","onScroll","_checkSortOverlap","checkOverlap","dragSortInterval","_sortPredicate","dragSortPredicate","defaultSortPredicate","reset","Pan","pointers","threshold","direction","DIRECTION_ALL","Press","time","isPlainObject","dragHammerSettings","set","on","getItem","onMove","isResolved","onEnd","preventDefault","normalizeArrayIndex","array","index","isMigration","maxIndex","max","arraySwap","withIndex","temp","indexA","indexB","arrayMove","fromIndex","toIndex","from","to","val","toString","target","source","keys","isObject","concat","insertItemsToArray","targetIndex","wait","timeout","action","clearTimeout","getComputedStyle","getPropertyValue","getStyleAsFloat","parseFloat","getTranslateAsFloat","axis","replace","split","translateX","translateY","getCurrentStyles","styles","current","props","className","classList","removeClass","remove","trim","nodeList","getOffsetDiff","elemA","elemB","compareContainingBlocks","getContainingBlock","aOffset","getOffset","bOffset","excludeElementBorders","rect","pageXOffset","pageYOffset","self","getBoundingClientRect","isParent","parentElement","isTransformed","getScrollParents","overflowRegex","parent","test","elems","elem","isInner","createElement","position","visibility","outer","inner","isLeaking","removeChild","getRectOverlapScore","a","b","muuriLayout","doRectsOverlap","width","height","getItemIndexMap","compareItemIndices","itemA","itemB","isDescending","indexMap","gridShowHideHandler","method","targetItems","getItems","opts","isInstant","instant","callback","onFinish","counter","isShow","startEvent","endEvent","needsLayout","completedItems","hiddenItems","_emit","_skipNextLayoutAnimation","interrupted","currentStyles","duration","parseInt","showDuration","hideDuration","easing","showEasing","hideEasing","isEnabled","isAnimating","stop","targetStyles","processQueue","instance","callbacks","isItemInState","state","methodName","isVisible","dragStartPredicateResolve","handleRect","x","y","predicate","_startPredicateData","pointer","changedPointers","pageX","pageY","distance","delay","handleElement","dragStartPredicateReset","delayTimer","slotIds","slotData","slot","itemWidth","itemHeight","fillGaps","isHorizontal","horizontal","alignRight","alignBottom","rounding","slots","round","setWidth","setHeight","freeSlots","_width","_margin","right","_height","bottom","getSlot","Layout","layoutSettings","_border","opacity","layoutDuration","layoutEasing","sortData","dragContainer","handle","dragAxis","dragReleaseDuration","dragReleaseEasing","touchAction","itemPositioningClass","itemDraggingClass","itemReleasingClass","listener","once","off","getElement","targets","hasTargets","targetState","_getItem","refreshSortData","synchronize","fragment","createDocumentFragment","isBorderBox","containerStyles","tryFinish","isDragging","elements","targetElements","newItems","elementIndex","allItems","indices","_destroy","removeElements","show","hide","filter","predicateType","isPredicateString","isPredicateFn","itemsToShow","itemsToHide","tryFinishCounter","sort","comparer","descending","origItems","result","criterias","criteriaName","criteriaOrder","valA","valB","_sortData","compareItems","refItems","currentItems","sortItemsByReference","reverse","move","isSwap","fromItem","toItem","send","targetGrid","appendTo","layoutSender","layoutReceiver","destroy","removeEventListener","emit","arguments","sides","getWidth","getHeight","getMargin","getPosition","isShowing","isHiding","isPositioning","isReleasing","isDestroyed","side","margin","getters","key","offsetLeft","offsetTop","currentLeft","currentTop","migrate","release","isJustReleased","animDuration","animEasing","animEnabled","_stopLayout","_finishLayout","processLayoutQueue","_show","_hide","removeElement","removeAttribute","listeners","arg1","arg2","arg3","listenersLength","argsLength","eventNames","propsFrom","propsTo","some","onfinish","animate","currentProps","currentContainer","offsetDiff","containerDiff","isItemVisible","currentGrid","currentGridStn","targetGridStn","targetGridElement","targetContainer","fromGrid","toGrid","abort","gridElement","config","isAnchor","href","abs","isFinal","tagName","getAttribute","deltaX","deltaY","deltaTime","open","location","matchIndex","hasValidTargets","score","dragData","rootGrid","sortThreshold","sortAction","itemRect","elementClientX","elementClientY","gridScore","grids","bestScore","getTargetGrid","gridOffsetLeft","gridOffsetTop","matchScore","gridX","gridY","Infinity","containingBlock","currentEvent","scrollers","bindScrollListeners","gridContainer","len","arrayUnique","unbindScrollListeners","finishMigration","targetSettings","currentSettings","cancelRafLoop","elementRect","xDiff","yDiff","vertical","potentialSlots","ignoreCurrentSlots","ii","newSlots","splitRect","purgeRects","sortRectsTopLeft","sortRectsLeftTop","hole","isRectWithinRect","rects","rectA","rectB","exportName","assign","VENDOR_PREFIXES","TEST_ELEMENT","TYPE_FUNCTION","now","Date","setTimeoutContext","context","bindFn","invokeArrayArg","arg","each","obj","iterator","deprecate","message","deprecationMessage","stack","log","console","warn","TypeError","output","nextKey","extend","dest","src","merge","inherit","child","base","properties","childP","baseP","create","constructor","_super","boolOrFn","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","removeEventListeners","hasParent","node","inStr","str","find","inArray","findByKey","toArray","uniqueArray","results","values","prefixed","prop","camelProp","_uniqueId","getWindowForElement","ownerDocument","defaultView","parentWindow","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","navigator","userAgent","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","PROPS_XY","PROPS_CLIENT_XY","Input","manager","inputTarget","domHandler","ev","enable","init","inputHandler","eventType","input","pointersLen","changedPointersLen","isFirst","session","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","angle","getAngle","getDistance","offset","offsetDelta","prevDelta","prevInput","computeDeltaXY","offsetDirection","getDirection","overallVelocity","getVelocity","overallVelocityX","overallVelocityY","scale","end","rotation","getRotation","maxPointers","velocity","velocityX","velocityY","last","lastInterval","v","computeIntervalInputData","srcEvent","computeInputData","recognize","clientX","clientY","p1","p2","sqrt","atan2","PI","evEl","evTarget","evWin","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","pressed","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","store","pointerEvents","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","touches","all","changed","changedTouches","TOUCH_INPUT_MAP","TOUCH_TARGET_EVENTS","TouchInput","targetIds","allTouches","identifier","targetTouches","changedTargetTouches","touch","DEDUP_TIMEOUT","DEDUP_DISTANCE","TouchMouseInput","mouse","primaryTouch","lastTouches","setLastTouch","eventData","lastTouch","lts","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","t","dx","dy","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","getTouchActionProps","TouchAction","compute","actions","update","recognizers","recognizer","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","prevented","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","Recognizer","defaults","simultaneous","requireFail","stateStr","directionStr","getRecognizerByNameIfManager","otherRecognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","preset","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","process","attrTest","optionPointers","isRecognized","isValid","directionTest","hasMoved","inOut","validPointers","validMovement","validTime","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","handlers","oldCssProps","toggleCssProps","force","stopped","curRecognizer","existing","events","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","STATE_FAILED","Tap","Swipe","Pinch","Rotate","IdManager","_class","IdManager_classCallCheck","_initialized","TPL_ANSWER_CONTAINER","TPL_CANDIDATES_CONTAINER","IdManager_createClass","pid","template","itemid","GridSystem","answerContainer","candidatesContainer","hiddenInputs","GridSystem_classCallCheck","columnGrids","generate_muuri","boardGrid","muuri_default","that","src_generate_ui","nullAnswersContainer","getElementById","stringify","nullCandidatesContainer","src_GridSystem","webpackPolyfill","paths"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/*!\n * Muuri v0.5.4\n * https://github.com/haltu/muuri\n * Copyright (c) 2015, Haltu Oy\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function (global, factory) {\n\n  var namespace = 'Muuri';\n  var Hammer;\n\n  if (typeof module === 'object' && module.exports) {\n    /* eslint-disable */\n    try { Hammer = require('hammerjs'); } catch (e) {}\n    /* eslint-enable */\n    module.exports = factory(namespace, Hammer);\n  }\n  else if (typeof define === 'function' && define.amd) {\n    define(['hammerjs'], function (Hammer) {\n      return factory(namespace, Hammer);\n    });\n  }\n  else {\n    global[namespace] = factory(namespace, global.Hammer);\n  }\n\n}(typeof window !== 'undefined' ? window : this, function (namespace, Hammer, undefined) {\n\n  'use strict';\n\n  // Get references to all the stuff we are using from the global scope.\n  var global = window;\n  var Object = global.Object;\n  var Array = global.Array;\n  var Math = global.Math;\n  var Error = global.Error;\n  var Element = global.Element;\n  var doc = global.document;\n  var docElem = doc.documentElement;\n  var body = doc.body;\n\n  // Types.\n  var typeFunction = 'function';\n  var typeString = 'string';\n  var typeNumber = 'number';\n\n  // Raf loop that can be used to organize DOM write and read operations\n  // optimally in the next animation frame.\n  var rafLoop = createRafLoop();\n\n  // Raf loop queue names.\n  var rafQueueLayout = 'layout';\n  var rafQueueVisibility = 'visibility';\n  var rafQueueMove = 'move';\n  var rafQueueScroll = 'scroll';\n\n  // Drag start predicate states.\n  var startPredicateInactive = 0;\n  var startPredicatePending = 1;\n  var startPredicateResolved = 2;\n  var startPredicateRejected = 3;\n\n  // Keep track of Grid instances.\n  var gridInstances = {};\n\n  // Keep track of Item instances.\n  var itemInstances = {};\n\n  // No operation function.\n  var noop = function () {};\n\n  // Unique id which is used for Grid instances and Item instances.\n  // Should be incremented every time when used.\n  var uuid = 0;\n\n  // Get the supported element.matches().\n  var elementMatches = getSupportedElementMatches();\n\n  // Get the supported transform style property.\n  var transform = getSupportedStyle('transform');\n\n  // Test if transformed elements leak fixed elements.\n  var transformLeaksFixed = body ? doesTransformLeakFixed() : null;\n\n  // Event names.\n  var evSynchronize = 'synchronize';\n  var evLayoutStart = 'layoutStart';\n  var evLayoutEnd = 'layoutEnd';\n  var evAdd = 'add';\n  var evRemove = 'remove';\n  var evShowStart = 'showStart';\n  var evShowEnd = 'showEnd';\n  var evHideStart = 'hideStart';\n  var evHideEnd = 'hideEnd';\n  var evFilter = 'filter';\n  var evSort = 'sort';\n  var evMove = 'move';\n  var evSend = 'send';\n  var evBeforeSend = 'beforeSend';\n  var evReceive = 'receive';\n  var evBeforeReceive = 'beforeReceive';\n  var evDragInit = 'dragInit';\n  var evDragStart = 'dragStart';\n  var evDragMove = 'dragMove';\n  var evDragScroll = 'dragScroll';\n  var evDragEnd = 'dragEnd';\n  var evDragReleaseStart = 'dragReleaseStart';\n  var evDragReleaseEnd = 'dragReleaseEnd';\n  var evDestroy = 'destroy';\n\n  /**\n   * Grid\n   * ****\n   */\n\n  /**\n   * Creates a new Grid instance.\n   *\n   * @public\n   * @class\n   * @param {(HTMLElement|String)} element\n   * @param {Object} [options]\n   * @param {(?HTMLElement[]|NodeList|String)} [options.items]\n   * @param {Number} [options.showDuration=300]\n   * @param {String} [options.showEasing=\"ease\"]\n   * @param {Object} [options.visibleStyles]\n   * @param {Number} [options.hideDuration=300]\n   * @param {String} [options.hideEasing=\"ease\"]\n   * @param {Object} [options.hiddenStyles]\n   * @param {(Function|Object)} [options.layout]\n   * @param {Boolean} [options.layout.fillGaps=false]\n   * @param {Boolean} [options.layout.horizontal=false]\n   * @param {Boolean} [options.layout.alignRight=false]\n   * @param {Boolean} [options.layout.alignBottom=false]\n   * @param {Boolean} [options.layout.rounding=true]\n   * @param {(Boolean|Number)} [options.layoutOnResize=100]\n   * @param {Boolean} [options.layoutOnInit=true]\n   * @param {Number} [options.layoutDuration=300]\n   * @param {String} [options.layoutEasing=\"ease\"]\n   * @param {?Object} [options.sortData=null]\n   * @param {Boolean} [options.dragEnabled=false]\n   * @param {?HtmlElement} [options.dragContainer=null]\n   * @param {?Function} [options.dragStartPredicate]\n   * @param {Number} [options.dragStartPredicate.distance=0]\n   * @param {Number} [options.dragStartPredicate.delay=0]\n   * @param {(Boolean|String)} [options.dragStartPredicate.handle=false]\n   * @param {?String} [options.dragAxis]\n   * @param {(Boolean|Function)} [options.dragSort=true]\n   * @param {Number} [options.dragSortInterval=100]\n   * @param {(Function|Object)} [options.dragSortPredicate]\n   * @param {Number} [options.dragSortPredicate.threshold=50]\n   * @param {String} [options.dragSortPredicate.action=\"move\"]\n   * @param {Number} [options.dragReleaseDuration=300]\n   * @param {String} [options.dragReleaseEasing=\"ease\"]\n   * @param {Object} [options.dragHammerSettings={touchAction: \"none\"}]\n   * @param {String} [options.containerClass=\"muuri\"]\n   * @param {String} [options.itemClass=\"muuri-item\"]\n   * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n   * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n   * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n   * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n   * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n   */\n  function Grid(element, options) {\n\n    var inst = this;\n    var settings;\n    var items;\n    var layoutOnResize;\n\n    // Muuri can be loaded inside the head tag also, but in that case Muuri can\n    // not cache body element and run the initial DOM tests. So, if we detect\n    // that body element could not be fetched on init we do it here once and\n    // also run the DOM tests. If the Grid is instantiated before body is ready\n    // you are doing it wrong ;)\n    if (!body) {\n      body = document.body;\n      transformLeaksFixed = doesTransformLeakFixed();\n    }\n\n    // Allow passing element as selector string. Store element for instance.\n    element = inst._element = typeof element === typeString ? doc.querySelector(element) : element;\n\n    // Throw an error if the container element is not body element or does not\n    // exist within the body element.\n    if (!body.contains(element)) {\n      throw new Error('Container element must be an existing DOM element');\n    }\n\n    // Create instance settings by merging the options with default options.\n    settings = inst._settings = mergeSettings(Grid.defaultOptions, options);\n\n    // Sanitize dragSort setting.\n    if (typeof settings.dragSort !== typeFunction) {\n      settings.dragSort = !!settings.dragSort;\n    }\n\n    // Create instance id and store it to the grid instances collection.\n    gridInstances[inst._id = ++uuid] = inst;\n\n    // Destroyed flag.\n    inst._isDestroyed = false;\n\n    // Reference to the currently used Layout instance.\n    inst._layout = null;\n\n    // Create private Emitter instance.\n    inst._emitter = new Grid.Emitter();\n\n    // Setup grid's show/hide animation handler for items.\n    inst._itemShowHandler = getItemVisibilityHandler('show', settings);\n    inst._itemHideHandler = getItemVisibilityHandler('hide', settings);\n\n    // Add container element's class name.\n    addClass(element, settings.containerClass);\n\n    // Create initial items.\n    inst._items = [];\n    items = settings.items;\n    if (typeof items === typeString) {\n      nodeListToArray(inst._element.children).forEach(function (itemElement) {\n        if (items === '*' || elementMatches(itemElement, items)) {\n          inst._items.push(new Grid.Item(inst, itemElement));\n        }\n      });\n    }\n    else if (Array.isArray(items) || isNodeList(items)) {\n      inst._items = nodeListToArray(items).map(function (itemElement) {\n        return new Grid.Item(inst, itemElement);\n      });\n    }\n\n    // Sanitize layoutOnResize option and bind debounced resize handler if the\n    // layoutOnResize option a valid number.\n    layoutOnResize = settings.layoutOnResize;\n    layoutOnResize = layoutOnResize === true ? 0 : typeof layoutOnResize === typeNumber ? layoutOnResize : -1;\n    if (layoutOnResize >= 0) {\n      global.addEventListener('resize', inst._resizeHandler = debounce(function () {\n        inst.refreshItems().layout();\n      }, layoutOnResize));\n    }\n\n    // Layout on init if necessary.\n    if (settings.layoutOnInit) {\n      inst.layout(true);\n    }\n\n  }\n\n  /**\n   * Grid - Public properties\n   * ************************\n   */\n\n  /**\n   * @see Item\n   */\n  Grid.Item = Item;\n\n  /**\n   * @see ItemDrag\n   */\n  Grid.ItemDrag = ItemDrag;\n\n  /**\n   * @see ItemRelease\n   */\n  Grid.ItemRelease = ItemRelease;\n\n  /**\n   * @see ItemMigrate\n   */\n  Grid.ItemMigrate = ItemMigrate;\n\n  /**\n   * @see ItemAnimate\n   */\n  Grid.ItemAnimate = ItemAnimate;\n\n  /**\n   * @see Layout\n   */\n  Grid.Layout = Layout;\n\n  /**\n   * @see Emitter\n   */\n  Grid.Emitter = Emitter;\n\n  /**\n   * Default options for Grid instance.\n   *\n   * @public\n   * @memberof Grid\n   */\n  Grid.defaultOptions = {\n\n    // Item elements\n    items: '*',\n\n    // Default show animation\n    showDuration: 300,\n    showEasing: 'ease',\n\n    // Default hide animation\n    hideDuration: 300,\n    hideEasing: 'ease',\n\n    // Item's visible/hidden state styles\n    visibleStyles: {\n      opacity: '1',\n      transform: 'scale(1)'\n    },\n    hiddenStyles: {\n      opacity: '0',\n      transform: 'scale(0.5)'\n    },\n\n    // Layout\n    layout: {\n      fillGaps: false,\n      horizontal: false,\n      alignRight: false,\n      alignBottom: false,\n      rounding: true\n    },\n    layoutOnResize: 100,\n    layoutOnInit: true,\n    layoutDuration: 300,\n    layoutEasing: 'ease',\n\n    // Sorting\n    sortData: null,\n\n    // Drag & Drop\n    dragEnabled: false,\n    dragContainer: null,\n    dragStartPredicate: {\n      distance: 0,\n      delay: 0,\n      handle: false\n    },\n    dragAxis: null,\n    dragSort: true,\n    dragSortInterval: 100,\n    dragSortPredicate: {\n      threshold: 50,\n      action: 'move'\n    },\n    dragReleaseDuration: 300,\n    dragReleaseEasing: 'ease',\n    dragHammerSettings: {\n      touchAction: 'none'\n    },\n\n    // Classnames\n    containerClass: 'muuri',\n    itemClass: 'muuri-item',\n    itemVisibleClass: 'muuri-item-shown',\n    itemHiddenClass: 'muuri-item-hidden',\n    itemPositioningClass: 'muuri-item-positioning',\n    itemDraggingClass: 'muuri-item-dragging',\n    itemReleasingClass: 'muuri-item-releasing'\n\n  };\n\n  /**\n   * Grid - Private properties\n   * *************************\n   */\n\n  Grid._maxRafBatchSize = 100;\n\n  /**\n   * Grid - Public prototype methods\n   * *******************************\n   */\n\n  /**\n   * Bind an event listener.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.on = function (event, listener) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.on(event, listener);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Bind an event listener that is triggered only once.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.once = function (event, listener) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.once(event, listener);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Unbind an event listener.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.off = function (event, listener) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.off(event, listener);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Get the container element.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @returns {HTMLElement}\n   */\n  Grid.prototype.getElement = function () {\n\n    return this._element;\n\n  };\n\n  /**\n   * Get all items. Optionally you can provide specific targets (elements and\n   * indices) and filter the results based on the state of the items. Note that\n   * the returned array is not the same object used by the instance so modifying\n   * it will not affect instance's items. All items that are not found are\n   * omitted from the returned array.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} [targets]\n   * @param {GridItemState} [state]\n   * @returns {Item[]}\n   */\n  Grid.prototype.getItems = function (targets, state) {\n\n    var inst = this;\n\n    // Return an empty array immediately if the instance is destroyed.\n    if (inst._isDestroyed) {\n      return [];\n    }\n\n    var hasTargets = targets === 0 || (targets && typeof targets !== typeString);\n    var targetItems = !hasTargets ? null : isNodeList(targets) ? nodeListToArray(targets) : [].concat(targets);\n    var targetState = !hasTargets ? targets : state;\n    var ret = [];\n    var item;\n    var i;\n\n    // Sanitize target state.\n    targetState = typeof targetState === typeString ? targetState : null;\n\n    // If target state or target items are defined return filtered results.\n    if (targetState || targetItems) {\n      targetItems = targetItems || inst._items;\n      for (i = 0; i < targetItems.length; i++) {\n        item = hasTargets ? inst._getItem(targetItems[i]) : targetItems[i];\n        if (item && (!targetState || isItemInState(item, targetState))) {\n          ret.push(item);\n        }\n      }\n      return ret;\n    }\n\n    // Otherwise return all items.\n    else {\n      return ret.concat(inst._items);\n    }\n\n  };\n\n  /**\n   * Update the cached dimensions of the instance's items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} [items]\n   * @returns {Grid}\n   */\n  Grid.prototype.refreshItems = function (items) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var targetItems = inst.getItems(items || 'active');\n    var i;\n\n    for (i = 0; i < targetItems.length; i++) {\n      targetItems[i]._refreshDimensions();\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Update the sort data of the instance's items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} [items]\n   * @returns {Grid}\n   */\n  Grid.prototype.refreshSortData = function (items) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var targetItems = inst.getItems(items);\n    var i;\n\n    for (i = 0; i < targetItems.length; i++) {\n      targetItems[i]._refreshSortData();\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Synchronize the item elements to match the order of the items in the DOM.\n   * This comes handy if you need to keep the DOM structure matched with the\n   * order of the items. Note that if an item's element is not currently a child\n   * of the container element (if it is dragged for example) it is ignored and\n   * left untouched.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @returns {Grid}\n   */\n  Grid.prototype.synchronize = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var container = inst._element;\n    var items = inst._items;\n    var fragment;\n    var element;\n    var i;\n\n    // Append all elements in order to the container element.\n    if (items.length) {\n      for (i = 0; i < items.length; i++) {\n        element = items[i]._element;\n        if (element.parentNode === container) {\n          fragment = fragment || doc.createDocumentFragment();\n          fragment.appendChild(element);\n        }\n      }\n      if (fragment) {\n        container.appendChild(fragment);\n      }\n    }\n\n    // Emit synchronize event.\n    inst._emit(evSynchronize);\n\n    return inst;\n\n  };\n\n  /**\n   * Calculate and apply item positions.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {Boolean} [instant=false]\n   * @param {LayoutCallback} [onFinish]\n   * @returns {Grid}\n   */\n  Grid.prototype.layout = function (instant, onFinish) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var callback = typeof instant === typeFunction ? instant : onFinish;\n    var isInstant = instant === true;\n    var items = inst.getItems('active');\n    var layout = inst._layout = new Grid.Layout(inst, items);\n    var counter = items.length;\n    var isBorderBox;\n    var containerStyles;\n    var item;\n    var position;\n    var i;\n\n    // The finish function, which will be used for checking if all the items\n    // have laid out yet. After all items have finished their animations call\n    // callback and emit layoutEnd event. Only emit layoutEnd event if there\n    // hasn't been a new layout call during this layout.\n    function tryFinish() {\n      if (--counter <= 0) {\n        if (typeof callback === typeFunction) {\n          callback(inst._layout !== layout, items.concat());\n        }\n        if (inst._layout === layout) {\n          inst._emit(evLayoutEnd, items.concat());\n        }\n      }\n    }\n\n    // If grid's width or height was modified, we need to update it's cached\n    // dimensions. Also keep in mind that grid's cached width/height should\n    // always equal to what elem.getBoundingClientRect() would return, so\n    // therefore we need to add the grid element's borders to the dimensions if\n    // it's box-sizing is border-box.\n    if (layout.setWidth || layout.setHeight) {\n\n      containerStyles = {};\n      isBorderBox = getStyle(inst._element, 'box-sizing') === 'border-box';\n\n      if (layout.setHeight) {\n        if (typeof layout.height === typeNumber) {\n          containerStyles.height = (isBorderBox ? layout.height + inst._border.top + inst._border.bottom : layout.height) + 'px';\n        }\n        else {\n          containerStyles.height = layout.height;\n        }\n      }\n\n      if (layout.setWidth) {\n        if (typeof layout.width === typeNumber) {\n          containerStyles.width = (isBorderBox ? layout.width + inst._border.left + inst._border.right : layout.width) + 'px';\n        }\n        else {\n          containerStyles.width = layout.width;\n        }\n      }\n\n      setStyles(inst._element, containerStyles);\n\n    }\n\n    // Emit layoutStart event. Note that this is intentionally emitted after the\n    // container element's dimensions are set, because otherwise there would be\n    // no hook for reacting to container dimension changes.\n    inst._emit(evLayoutStart, items.concat());\n\n    // If there are no items let's finish quickly.\n    if (!items.length) {\n      tryFinish();\n      return inst;\n    }\n\n    // If there are items let's position them.\n    for (i = 0; i < items.length; i++) {\n\n      item = items[i];\n      position = layout.slots[item._id];\n\n      // Update item's position.\n      item._left = position.left;\n      item._top = position.top;\n\n      // Layout non-dragged items.\n      if (item.isDragging()) {\n        tryFinish(true, item);\n      }\n      else {\n        item._layout(isInstant, tryFinish);\n      }\n\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Add new items by providing the elements you wish to add to the instance and\n   * optionally provide the index where you want the items to be inserted into.\n   * All elements that are not already children of the container element will be\n   * automatically appended to the container element. If an element has it's CSS\n   * display property set to \"none\" it will be marked as inactive during the\n   * initiation process. As long as the item is inactive it will not be part of\n   * the layout, but it will retain it's index. You can activate items at any\n   * point with grid.show() method. This method will automatically call\n   * grid.layout() if one or more of the added elements are visible. If only\n   * hidden items are added no layout will be called. All the new visible items\n   * are positioned without animation during their first layout.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(HTMLElement|HTMLElement[])} elements\n   * @param {Object} [options]\n   * @param {Number} [options.index=-1]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Item[]}\n   */\n  Grid.prototype.add = function (elements, options) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return [];\n    }\n\n    var targetElements = isNodeList(elements) ? nodeListToArray(elements) : [].concat(elements);\n    var newItems = [];\n\n    // Return early if there are no items.\n    if (!targetElements.length) {\n      return newItems;\n    }\n\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var items = inst._items;\n    var needsLayout = false;\n    var elementIndex;\n    var item;\n    var i;\n\n    // Filter out all elements that exist already in current instance.\n    // TODO: This filtering can be made a lot faster by storing item elements\n    // in a Map or WeakMap. Other option would be to transfer the reponsibility\n    // completely to the user and get rid of this sanity check.\n    for (i = 0; i < items.length; i++) {\n      elementIndex = targetElements.indexOf(items[i]._element);\n      if (elementIndex > -1) {\n        targetElements.splice(elementIndex, 1);\n        if (!targetElements.length) {\n          return newItems;\n        }\n      }\n    }\n\n    // Create new items.\n    for (i = 0; i < targetElements.length; i++) {\n\n      item = new Grid.Item(inst, targetElements[i]);\n      newItems.push(item);\n\n      // If the item to be added is active, we need to do a layout. Also, we\n      // need to mark the item with the skipNextLayoutAnimation flag to make it\n      // position instantly (without animation) during the next layout. Without\n      // the hack the item would animate to it's new position from the northwest\n      // corner of the grid, which feels a bit buggy (imho).\n      if (item._isActive) {\n        needsLayout = true;\n        item._skipNextLayoutAnimation = true;\n      }\n\n    }\n\n    // Add the new items to the items collection to correct index.\n    insertItemsToArray(items, newItems, opts.index);\n\n    // Emit add event.\n    inst._emit(evAdd, newItems.concat());\n\n    // If layout is needed.\n    if (needsLayout && layout) {\n      inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n    }\n\n    // Return new items.\n    return newItems;\n\n  };\n\n  /**\n   * Remove items from the instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.removeElements=false]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Item[]}\n   */\n  Grid.prototype.remove = function (items, options) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var needsLayout = false;\n    var allItems = inst.getItems();\n    var targetItems = inst.getItems(items);\n    var indices = [];\n    var item;\n    var i;\n\n    // Remove the individual items.\n    for (i = 0; i < targetItems.length; i++) {\n      item = targetItems[i];\n      indices.push(allItems.indexOf(item));\n      if (item._isActive) {\n        needsLayout = true;\n      }\n      item._destroy(opts.removeElements);\n    }\n\n    // Emit remove event.\n    inst._emit(evRemove, targetItems.concat(), indices);\n\n    // If layout is needed.\n    if (needsLayout && layout) {\n      inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n    }\n\n    return targetItems;\n\n  };\n\n  /**\n   * Show instance items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {ShowCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.show = function (items, options) {\n\n    return this._isDestroyed ? this : gridShowHideHandler(this, 'show', items, options);\n\n  };\n\n  /**\n   * Hide instance items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {HideCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.hide = function (items, options) {\n\n    return this._isDestroyed ? this : gridShowHideHandler(this, 'hide', items, options);\n\n  };\n\n  /**\n   * Filter items. Expects at least one argument, a predicate, which should be\n   * either a function or a string. The predicate callback is executed for every\n   * item in the instance. If the return value of the predicate is truthy the\n   * item in question will be shown and otherwise hidden. The predicate callback\n   * receives the item instance as it's argument. If the predicate is a string\n   * it is considered to be a selector and it is checked against every item\n   * element in the instance with the native element.matches() method. All the\n   * matching items will be shown and others hidden.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(Function|String)} predicate\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {FilterCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.filter = function (predicate, options) {\n\n    var inst = this;\n\n    // Return immediately if there are no items or if the instance id destroyed.\n    if (inst._isDestroyed || !inst._items.length) {\n      return inst;\n    }\n\n    var items = inst._items;\n    var predicateType = typeof predicate;\n    var isPredicateString = predicateType === typeString;\n    var isPredicateFn = predicateType === typeFunction;\n    var opts = options || {};\n    var isInstant = opts.instant === true;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var onFinish = typeof opts.onFinish === typeFunction ? opts.onFinish : null;\n    var itemsToShow = [];\n    var itemsToHide = [];\n    var tryFinishCounter = -1;\n    var tryFinish = !onFinish ? noop : function () {\n      ++tryFinishCounter && onFinish(itemsToShow.concat(), itemsToHide.concat());\n    };\n    var item;\n    var i;\n\n    // Check which items need to be shown and which hidden.\n    if (isPredicateFn || isPredicateString) {\n      for (i = 0; i < items.length; i++) {\n        item = items[i];\n        if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n          itemsToShow.push(item);\n        }\n        else {\n          itemsToHide.push(item);\n        }\n      }\n    }\n\n    // Show items that need to be shown.\n    if (itemsToShow.length) {\n      inst.show(itemsToShow, {\n        instant: isInstant,\n        onFinish: tryFinish,\n        layout: false\n      });\n    }\n    else {\n      tryFinish();\n    }\n\n    // Hide items that need to be hidden.\n    if (itemsToHide.length) {\n      inst.hide(itemsToHide, {\n        instant: isInstant,\n        onFinish: tryFinish,\n        layout: false\n      });\n    }\n    else {\n      tryFinish();\n    }\n\n    // If there are any items to filter.\n    if (itemsToShow.length || itemsToHide.length) {\n\n      // Emit filter event.\n      inst._emit(evFilter, itemsToShow.concat(), itemsToHide.concat());\n\n      // If layout is needed.\n      if (layout) {\n        inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n      }\n\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Sort items. There are three ways to sort the items. The first is simply by\n   * providing a function as the comparer which works identically to native\n   * array sort. Alternatively you can sort by the sort data you have provided\n   * in the instance's options. Just provide the sort data key(s) as a string\n   * (separated by space) and the items will be sorted based on the provided\n   * sort data keys. Lastly you have the opportunity to provide a presorted\n   * array of items which will be used to sync the internal items array in the\n   * same order.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(Function|Item[]|String|String[])} comparer\n   * @param {Object} [options]\n   * @param {Boolean} [options.descending=false]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.sort = function (comparer, options) {\n\n    var inst = this;\n\n    // Let's not sort if it has no effect.\n    if (inst._isDestroyed || inst._items.length < 2) {\n      return inst;\n    }\n\n    var items = inst._items;\n    var opts = options || {};\n    var isDescending = !!opts.descending;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var origItems = items.concat();\n    var indexMap;\n\n    // If function is provided do a native array sort.\n    if (typeof comparer === typeFunction) {\n      items.sort(function (a, b) {\n        var result = comparer(a, b);\n        return (isDescending && result !== 0 ? -result : result) || compareItemIndices(a, b, isDescending, indexMap || (indexMap = getItemIndexMap(origItems)));\n      });\n    }\n\n    // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof comparer === typeString) {\n      comparer = comparer.trim().split(' ').map(function (val) {\n        return val.split(':');\n      });\n      items.sort(function (a, b) {\n        return compareItems(a, b, isDescending, comparer) || compareItemIndices(a, b, isDescending, indexMap || (indexMap = getItemIndexMap(origItems)));\n      });\n    }\n\n    // Otherwise if we got an array, let's assume it's a presorted array of the\n    // items and order the items based on it.\n    else if (Array.isArray(comparer)) {\n      sortItemsByReference(items, comparer);\n      if (isDescending) {\n        items.reverse();\n      }\n    }\n\n    // Otherwise, let's go home.\n    else {\n      return inst;\n    }\n\n    // Emit sort event.\n    inst._emit(evSort, items.concat(), origItems);\n\n    // If layout is needed.\n    if (layout) {\n      inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Move item to another index or in place of another item.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} item\n   * @param {GridSingleItemQuery} position\n   * @param {Object} [options]\n   * @param {String} [options.action=\"move\"]\n   *   - Accepts either \"move\" or \"swap\".\n   *   - \"move\" moves the item in place of the other item.\n   *   - \"swap\" swaps the position of the items.\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.move = function (item, position, options) {\n\n    var inst = this;\n\n    // Return immediately, if moving an item is not possible.\n    if (inst._isDestroyed || inst._items.length < 2) {\n      return inst;\n    }\n\n    var items = inst._items;\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var isSwap = opts.action === 'swap';\n    var action = isSwap ? 'swap' : 'move';\n    var fromItem = inst._getItem(item);\n    var toItem = inst._getItem(position);\n    var fromIndex;\n    var toIndex;\n\n    // Make sure the items exist and are not the same.\n    if (fromItem && toItem && (fromItem !== toItem)) {\n\n      // Get the indices of the items.\n      fromIndex = items.indexOf(fromItem);\n      toIndex = items.indexOf(toItem);\n\n      // Do the move/swap.\n      (isSwap ? arraySwap : arrayMove)(items, fromIndex, toIndex);\n\n      // Emit move event.\n      inst._emit(evMove, {\n        item: fromItem,\n        fromIndex: fromIndex,\n        toIndex: toIndex,\n        action: action\n      });\n\n      // If layout is needed.\n      if (layout) {\n        inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n      }\n\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Send item to another Grid instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} item\n   * @param {Grid} grid\n   * @param {GridSingleItemQuery} position\n   * @param {Object} [options]\n   * @param {HTMLElement} [options.appendTo=document.body]\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutSender=true]\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutReceiver=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.send = function (item, grid, position, options) {\n\n    var currentGrid = this;\n\n    // Return immediately if either grid is destroyed or if the grids are the\n    // same, or if target item was not found.\n    if (currentGrid._isDestroyed || grid._isDestroyed || currentGrid === grid || !(item = currentGrid._getItem(item))) {\n      return currentGrid;\n    }\n\n    var targetGrid = grid;\n    var opts = options || {};\n    var container = opts.appendTo || body;\n    var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n    var layoutReceiver = opts.layoutReceiver ? opts.layoutReceiver : opts.layoutReceiver === undefined;\n\n    // Start the migration process.\n    item._migrate.start(targetGrid, position, container);\n\n    // If migration was started succesfully and the item is active, let's layout\n    // the grids.\n    if (item._migrate.isActive && item.isActive()) {\n      if (layoutSender) {\n        currentGrid.layout(layoutSender === 'instant', typeof layoutSender === typeFunction ? layoutSender : undefined);\n      }\n      if (layoutReceiver) {\n        targetGrid.layout(layoutReceiver === 'instant', typeof layoutReceiver === typeFunction ? layoutReceiver : undefined);\n      }\n    }\n\n    return currentGrid;\n\n  };\n\n  /**\n   * Destroy the instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {Boolean} [removeElements=false]\n   * @returns {Grid}\n   */\n  Grid.prototype.destroy = function (removeElements) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var container = inst._element;\n    var items = inst._items.concat();\n    var i;\n\n    // Unbind window resize event listener.\n    if (inst._resizeHandler) {\n      global.removeEventListener('resize', inst._resizeHandler);\n    }\n\n    // Destroy items.\n    for (i = 0; i < items.length; i++) {\n      items[i]._destroy(removeElements);\n    }\n\n    // Restore container.\n    removeClass(container, inst._settings.containerClass);\n    setStyles(container, {height: ''});\n\n    // Emit destroy event and unbind all events.\n    inst._emit(evDestroy);\n    inst._emitter.destroy();\n\n    // Remove reference from the grid instances collection.\n    gridInstances[inst._id] = undefined;\n\n    // Flag instance as destroyed.\n    inst._isDestroyed = true;\n\n    return inst;\n\n  };\n\n  /**\n   * Grid - Protected prototype methods\n   * **********************************\n   */\n\n  /**\n   * Get instance's item by element or by index. Target can also be an Item\n   * instance in which case the function returns the item if it exists within\n   * related Grid instance. If nothing is found with the provided target, null\n   * is returned.\n   *\n   * @protected\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} [target=0]\n   * @returns {?Item}\n   */\n  Grid.prototype._getItem = function (target) {\n\n    var inst = this;\n    var items = inst._items;\n    var i;\n\n    // If no target is specified or the instance is destroyed, return the first\n    // item or null.\n    if (inst._isDestroyed || !target) {\n      return items[0] || null;\n    }\n\n    // If target is number return the item in that index. If the number is lower\n    // than zero look for the item starting from the end of the items array. For\n    // example -1 for the last item, -2 for the second last item, etc.\n    else if (typeof target === typeNumber) {\n      return items[target > -1 ? target : items.length + target] || null;\n    }\n\n    // If the target is an instance of Item return it if it is attached to this\n    // Grid instance, otherwise return null.\n    else if (target instanceof Item) {\n      return target._gridId === inst._id ? target : null;\n    }\n\n    // In other cases let's assume that the target is an element, so let's try\n    // to find an item that matches the element and return it. If item is not\n    // found return null.\n    else {\n      // TODO: This could be made a lot faster by using WeakMap or Map.\n      for (i = 0; i < items.length; i++) {\n        if (items[i]._element === target) {\n          return items[i];\n        }\n      }\n      return null;\n    }\n\n  };\n\n  /**\n   * Bind an event listener.\n   *\n   * @protected\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {*} [arg1]\n   * @param {*} [arg2]\n   * @param {*} [arg3]\n   * @returns {Grid}\n   */\n  Grid.prototype._emit = function () {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.emit.apply(inst._emitter, arguments);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Refresh container's internal dimensions.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @returns {Grid}\n   */\n  Grid.prototype._refreshDimensions = function () {\n\n    var inst = this;\n    var element = inst._element;\n    var rect = element.getBoundingClientRect();\n    var sides = ['left', 'right', 'top', 'bottom'];\n    var i;\n\n    inst._width = rect.width;\n    inst._height = rect.height;\n    inst._left = rect.left;\n    inst._top = rect.top;\n    inst._border = {};\n\n    for (i = 0; i < sides.length; i++) {\n      inst._border[sides[i]] = getStyleAsFloat(element, 'border-' + sides[i] + '-width');\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Item\n   * ****\n   */\n\n  /**\n   * Creates a new Item instance for a Grid instance.\n   *\n   * @public\n   * @class\n   * @param {Grid} grid\n   * @param {HTMLElement} element\n   */\n  function Item(grid, element) {\n\n    var inst = this;\n    var settings = grid._settings;\n    var isHidden;\n\n    // Create instance id and add item to the itemInstances collection.\n    inst._id = ++uuid;\n    itemInstances[inst._id] = inst;\n\n    // Destroyed flag.\n    inst._isDestroyed = false;\n\n    // If the provided item element is not a direct child of the grid container\n    // element, append it to the grid container.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n    }\n\n    // Set item class.\n    addClass(element, settings.itemClass);\n\n    // Check if the element is hidden.\n    isHidden = getStyle(element, 'display') === 'none';\n\n    // Set visible/hidden class.\n    addClass(element, isHidden ? settings.itemHiddenClass : settings.itemVisibleClass);\n\n    // Refrence to connected Grid instance's id.\n    inst._gridId = grid._id;\n\n    // The elements.\n    inst._element = element;\n    inst._child = element.children[0];\n\n    // Initiate item's animation controllers.\n    inst._animate = new Grid.ItemAnimate(inst, element);\n    inst._animateChild = new Grid.ItemAnimate(inst, inst._child);\n\n    // Set up active state (defines if the item is considered part of the layout\n    // or not).\n    inst._isActive = isHidden ? false : true;\n\n    // Set up positioning state (defines if the item is currently animating\n    // it's position).\n    inst._isPositioning = false;\n\n    // Set up visibility states.\n    inst._isHidden = isHidden;\n    inst._isHiding = false;\n    inst._isShowing = false;\n\n    // Visibility animation callback queue. Whenever a callback is provided for\n    // show/hide methods and animation is enabled the callback is stored\n    // temporarily to this array. The callbacks are called with the first\n    // argument as false if the animation succeeded without interruptions and\n    // with the first argument as true if the animation was interrupted.\n    inst._visibilityQueue = [];\n\n    // Layout animation callback queue. Whenever a callback is provided for\n    // layout method and animation is enabled the callback is stored temporarily\n    // to this array. The callbacks are called with the first argument as false\n    // if the animation succeeded without interruptions and with the first\n    // argument as true if the animation was interrupted.\n    inst._layoutQueue = [];\n\n    // Set up initial positions.\n    inst._left = 0;\n    inst._top = 0;\n\n    // Set element's initial styles.\n    setStyles(element, {\n      left: '0',\n      top: '0',\n      transform: getTranslateString(0, 0),\n      display: isHidden ? 'none' : 'block'\n    });\n\n    // Set up the initial dimensions and sort data.\n    inst._refreshDimensions()._refreshSortData();\n\n    // Set initial styles for the child element.\n    if (isHidden) {\n      grid._itemHideHandler.start(inst, true);\n    }\n    else {\n      grid._itemShowHandler.start(inst, true);\n    }\n\n    // Set up migration handler data.\n    inst._migrate = new Grid.ItemMigrate(inst);\n\n    // Set up release handler\n    inst._release = new Grid.ItemRelease(inst);\n\n    // Set up drag handler.\n    inst._drag = settings.dragEnabled ? new Grid.ItemDrag(inst) : null;\n\n  }\n\n  /**\n   * Item - Public prototype methods\n   * *******************************\n   */\n\n  /**\n   * Get the instance grid reference.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Grid}\n   */\n  Item.prototype.getGrid = function () {\n\n    return gridInstances[this._gridId];\n\n  };\n\n  /**\n   * Get the instance element.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {HTMLElement}\n   */\n  Item.prototype.getElement = function () {\n\n    return this._element;\n\n  };\n\n  /**\n   * Get instance element's cached width.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Number}\n   */\n  Item.prototype.getWidth = function () {\n\n    return this._width;\n\n  };\n\n  /**\n   * Get instance element's cached height.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Number}\n   */\n  Item.prototype.getHeight = function () {\n\n    return this._height;\n\n  };\n\n  /**\n   * Get instance element's cached margins.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Object}\n   *   - The returned object contains left, right, top and bottom properties\n   *     which indicate the item element's cached margins.\n   */\n  Item.prototype.getMargin = function () {\n\n    return {\n      left: this._margin.left,\n      right: this._margin.right,\n      top: this._margin.top,\n      bottom: this._margin.bottom\n    };\n\n  };\n\n  /**\n   * Get instance element's cached position.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Object}\n   *   - The returned object contains left and top properties which indicate the\n   *     item element's cached position in the grid.\n   */\n  Item.prototype.getPosition = function () {\n\n    return {\n      left: this._left,\n      top: this._top\n    };\n\n  };\n\n  /**\n   * Is the item active?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isActive = function () {\n\n    return this._isActive;\n\n  };\n\n  /**\n   * Is the item visible?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isVisible = function () {\n\n    return !this._isHidden;\n\n  };\n\n  /**\n   * Is the item being animated to visible?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isShowing = function () {\n\n    return this._isShowing;\n\n  };\n\n  /**\n   * Is the item being animated to hidden?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isHiding = function () {\n\n    return this._isHiding;\n\n  };\n\n  /**\n   * Is the item positioning?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isPositioning = function () {\n\n    return this._isPositioning;\n\n  };\n\n  /**\n   * Is the item being dragged?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isDragging = function () {\n\n    return !!this._drag && this._drag._data.isActive;\n\n  };\n\n  /**\n   * Is the item being released?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isReleasing = function () {\n\n    return this._release.isActive;\n\n  };\n\n  /**\n   * Is the item destroyed?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isDestroyed = function () {\n\n    return this._isDestroyed;\n\n  };\n\n  /**\n   * Item - Protected prototype methods\n   * **********************************\n   */\n\n  /**\n   * Recalculate item's dimensions.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @returns {Item}\n   */\n  Item.prototype._refreshDimensions = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed || inst._isHidden) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var rect = element.getBoundingClientRect();\n    var sides = ['left', 'right', 'top', 'bottom'];\n    var margin = inst._margin = inst._margin || {};\n    var side;\n    var i;\n\n    // Calculate width and height.\n    inst._width = rect.width;\n    inst._height = rect.height;\n\n    // Calculate margins (ignore negative margins).\n    for (i = 0; i < 4; i++) {\n      side = getStyleAsFloat(element, 'margin-' + sides[i]);\n      margin[sides[i]] = side > 0 ? side : 0;\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Fetch and store item's sort data.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @returns {Item}\n   */\n  Item.prototype._refreshSortData = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var sortData = {};\n    var getters = inst.getGrid()._settings.sortData;\n\n    // Fetch sort data.\n    if (getters) {\n      Object.keys(getters).forEach(function (key) {\n        sortData[key] = getters[key](inst, inst._element);\n      });\n    }\n\n    // Store sort data to the instance.\n    inst._sortData = sortData;\n\n    return inst;\n\n  };\n\n  /**\n   * Position item based on it's current data.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} instant\n   * @param {Function} [onFinish]\n   * @returns {Item}\n   */\n  Item.prototype._layout = function (instant, onFinish) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var isPositioning = inst._isPositioning;\n    var migrate = inst._migrate;\n    var release = inst._release;\n    var isJustReleased = release.isActive && release.isPositioningStarted === false;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n    var animDuration = isJustReleased ? settings.dragReleaseDuration : settings.layoutDuration;\n    var animEasing = isJustReleased ? settings.dragReleaseEasing : settings.layoutEasing;\n    var animEnabled = !instant && !inst._skipNextLayoutAnimation && animDuration > 0;\n    var isAnimating;\n    var offsetLeft;\n    var offsetTop;\n    var currentLeft;\n    var currentTop;\n    var targetStyles;\n\n    // If the item is currently positioning process current layout callback\n    // queue with interrupted flag on if the item is currently positioning.\n    if (isPositioning) {\n      processQueue(inst._layoutQueue, true, inst);\n    }\n\n    // Mark release positioning as started.\n    if (isJustReleased) {\n      release.isPositioningStarted = true;\n    }\n\n    // Push the callback to the callback queue.\n    if (typeof onFinish === typeFunction) {\n      inst._layoutQueue.push(onFinish);\n    }\n\n    // Get item container offsets and target styles.\n    offsetLeft = release.isActive ? release.containerDiffX : migrate.isActive ? migrate.containerDiffX : 0;\n    offsetTop = release.isActive ? release.containerDiffY : migrate.isActive ? migrate.containerDiffY : 0;\n    targetStyles = {transform: getTranslateString(inst._left + offsetLeft, inst._top + offsetTop)};\n\n    // If no animations are needed, easy peasy!\n    if (!animEnabled) {\n      isPositioning && rafLoop.cancel(rafQueueLayout, inst._id);\n      isAnimating = inst._animate.isAnimating();\n      inst._stopLayout(false, targetStyles);\n      !isAnimating && setStyles(element, targetStyles);\n      inst._skipNextLayoutAnimation = false;\n      return inst._finishLayout();\n    }\n\n    // Set item as positioning.\n    inst._isPositioning = true;\n\n    // Get the element's current left and top position in the read callback.\n    // Then in the write callback do the animation if necessary.\n    rafLoop.add(rafQueueLayout, inst._id, function () {\n      currentLeft = getTranslateAsFloat(element, 'x') - offsetLeft;\n      currentTop = getTranslateAsFloat(element, 'y') - offsetTop;\n    }, function () {\n\n      // If the item is already in correct position let's quit early.\n      if (inst._left === currentLeft && inst._top === currentTop) {\n        isPositioning && inst._stopLayout(false, targetStyles);\n        inst._isPositioning = false;\n        return inst._finishLayout();\n      }\n\n      // Set item's positioning class.\n      !isPositioning && addClass(element, settings.itemPositioningClass);\n\n      // Animate.\n      inst._animate.start(\n        {transform: getTranslateString(currentLeft + offsetLeft, currentTop + offsetTop)},\n        targetStyles,\n        {\n          duration: animDuration,\n          easing: animEasing,\n          onFinish: function () {\n            inst._finishLayout();\n          }\n        }\n      );\n\n    });\n\n    return inst;\n\n  };\n\n  /**\n   * Position item based on it's current data.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @returns {Item}\n   */\n  Item.prototype._finishLayout = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    // Mark the item as not positioning and remove positioning classes.\n    if (inst._isPositioning) {\n      inst._isPositioning = false;\n      removeClass(inst._element, inst.getGrid()._settings.itemPositioningClass);\n    }\n\n    // Finish up release.\n    if (inst._release.isActive) {\n      inst._release.stop();\n    }\n\n    // Finish up migration.\n    if (inst._migrate.isActive) {\n      inst._migrate.stop();\n    }\n\n    // Process the callback queue.\n    processQueue(inst._layoutQueue, false, inst);\n\n    return inst;\n\n  };\n\n  /**\n   * Stop item's position animation if it is currently animating.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} [processLayoutQueue=false]\n   * @param {Object} [targetStyles]\n   * @returns {Item}\n   */\n  Item.prototype._stopLayout = function (processLayoutQueue, targetStyles) {\n\n    var inst = this;\n\n    if (inst._isDestroyed || !inst._isPositioning) {\n      return inst;\n    }\n\n    // Cancel animation init.\n    rafLoop.cancel(rafQueueLayout, inst._id);\n\n    // Stop animation.\n    inst._animate.stop(targetStyles);\n\n    // Remove positioning class.\n    removeClass(inst._element, inst.getGrid()._settings.itemPositioningClass);\n\n    // Reset state.\n    inst._isPositioning = false;\n\n    // Process callback queue.\n    if (processLayoutQueue) {\n      processQueue(inst._layoutQueue, true, inst);\n    }\n\n    return inst;\n\n  };\n\n  Item.prototype._show = function (instant, onFinish) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var queue = inst._visibilityQueue;\n    var callback = typeof onFinish === typeFunction ? onFinish : null;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n\n    // If item is visible call the callback and be done with it.\n    if (!inst._isShowing && !inst._isHidden) {\n      callback && callback(false, inst);\n      return inst;\n    }\n\n    // If item is showing and does not need to be shown instantly, let's just\n    // push callback to the callback queue and be done with it.\n    if (inst._isShowing && !instant) {\n      callback && queue.push(callback);\n      return inst;\n    }\n\n    // If the item is hiding or hidden process the current visibility callback\n    // queue with the interrupted flag active, update classes and set display\n    // to block if necessary.\n    if (!inst._isShowing) {\n      processQueue(queue, true, inst);\n      removeClass(element, settings.itemHiddenClass);\n      addClass(element, settings.itemVisibleClass);\n      !inst._isHiding && setStyles(element, {display: 'block'});\n    }\n\n    // Push callback to the callback queue.\n    callback && queue.push(callback);\n\n    // Update item's internal states.\n    inst._isActive = inst._isShowing = true;\n    inst._isHiding = inst._isHidden = false;\n\n    // If we need to show instantly.\n    if (instant) {\n      grid._itemShowHandler.stop(inst, settings.visibleStyles);\n      inst._isShowing = false;\n      processQueue(queue, false, inst);\n    }\n\n    // If we need to animate.\n    else {\n      grid._itemShowHandler.start(inst, instant, function () {\n        if (!inst._isHidden) {\n          inst._isShowing = false;\n          processQueue(queue, false, inst);\n        }\n      });\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Hide item.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} instant\n   * @param {Function} [onFinish]\n   * @returns {Item}\n   */\n  Item.prototype._hide = function (instant, onFinish) {\n\n    var inst = this;\n\n    // Return immediately if the instance is destroyed.\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var queue = inst._visibilityQueue;\n    var callback = typeof onFinish === typeFunction ? onFinish : null;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n\n    // If item is already hidden call the callback and be done with it.\n    if (!inst._isHiding && inst._isHidden) {\n      callback && callback(false, inst);\n      return inst;\n    }\n\n    // If item is hiding and does not need to be hidden instantly, let's just\n    // push callback to the callback queue and be done with it.\n    if (inst._isHiding && !instant) {\n      callback && queue.push(callback);\n      return inst;\n    }\n\n    // If the item is showing or visible process the current visibility callback\n    // queue with the interrupted flag active, update classes and set display\n    // to block if necessary.\n    if (!inst._isHiding) {\n      processQueue(queue, true, inst);\n      addClass(element, settings.itemHiddenClass);\n      removeClass(element, settings.itemVisibleClass);\n    }\n\n    // Push callback to the callback queue.\n    callback && queue.push(callback);\n\n    // Update item's internal states.\n    inst._isHidden = inst._isHiding = true;\n    inst._isActive = inst._isShowing = false;\n\n    // If we need to hide instantly.\n    if (instant) {\n      grid._itemHideHandler.stop(inst, settings.hiddenStyles);\n      inst._isHiding = false;\n      inst._stopLayout(true, {transform: getTranslateString(0, 0)});\n      setStyles(element, {display: 'none'});\n      processQueue(queue, false, inst);\n    }\n\n    // If we need to animate.\n    else {\n      grid._itemHideHandler.start(inst, instant, function () {\n        if (inst._isHidden) {\n          inst._isHiding = false;\n          inst._stopLayout(true, {transform: getTranslateString(0, 0)});\n          setStyles(element, {display: 'none'});\n          processQueue(queue, false, inst);\n        }\n      });\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Destroy item instance.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} [removeElement=false]\n   * @returns {Item}\n   */\n  Item.prototype._destroy = function (removeElement) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n    var index = grid._items.indexOf(inst);\n\n    // Destroy release and migration.\n    inst._release.destroy();\n    inst._migrate.destroy();\n\n    // Stop animations.\n    inst._stopLayout(true, {});\n    grid._itemShowHandler.stop(inst, {});\n    grid._itemHideHandler.stop(inst, {});\n\n    // Destroy drag.\n    inst._drag && inst._drag.destroy();\n\n    // Destroy animation handlers.\n    inst._animate.destroy();\n    inst._animateChild.destroy();\n\n    // Handle visibility callback queue, fire all uncompleted callbacks with\n    // interrupted flag.\n    processQueue(inst._visibilityQueue, true, inst);\n\n    // Remove all inline styles.\n    element.removeAttribute('style');\n    inst._child.removeAttribute('style');\n\n    // Remove classes.\n    removeClass(element, settings.itemPositioningClass);\n    removeClass(element, settings.itemDraggingClass);\n    removeClass(element, settings.itemReleasingClass);\n    removeClass(element, settings.itemClass);\n    removeClass(element, settings.itemVisibleClass);\n    removeClass(element, settings.itemHiddenClass);\n\n    // Remove item from Grid instance if it still exists there.\n    index > -1 && grid._items.splice(index, 1);\n\n    // Remove element from DOM.\n    removeElement && element.parentNode.removeChild(element);\n\n    // Remove item instance from the item instances collection.\n    itemInstances[inst._id] = undefined;\n\n    // Update item states (mostly just for good measure).\n    inst._isActive = inst._isPositioning = inst._isHiding = inst._isShowing = false;\n    inst._isDestroyed = inst._isHidden = true;\n\n    return inst;\n\n  };\n\n  /**\n   * Layout\n   * ******\n   */\n\n  /**\n   * Creates a new Layout instance.\n   *\n   * @public\n   * @class\n   * @param {Grid} grid\n   * @param {Item[]} items\n   */\n  function Layout(grid, items) {\n\n    var inst = this;\n    var layoutSettings = grid._settings.layout;\n\n    // Clone items.\n    items = items.concat();\n\n    // Let's make sure we have the correct container dimensions before going\n    // further.\n    grid._refreshDimensions();\n\n    var width = grid._width - grid._border.left - grid._border.right;\n    var height = grid._height - grid._border.top - grid._border.bottom;\n    var isCustomLayout = typeof layoutSettings === typeFunction;\n    var layout = isCustomLayout ? layoutSettings(items, width, height) :\n      muuriLayout(items, width, height, isPlainObject(layoutSettings) ? layoutSettings : {});\n\n    // Set instance data based on layout data.\n    inst.slots = layout.slots;\n    inst.setWidth = layout.setWidth || false;\n    inst.setHeight = layout.setHeight || false;\n    inst.width = layout.width;\n    inst.height = layout.height;\n\n  }\n\n  /**\n   * Emitter\n   * *******\n   */\n\n  /**\n   * Event emitter constructor.\n   *\n   * @public\n   * @class\n   */\n  function Emitter() {\n\n    this._events = {};\n    this._isDestroyed = false;\n\n  }\n\n  /**\n   * Emitter - Public prototype methods\n   * **********************************\n   */\n\n  /**\n   * Bind an event listener.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.on = function (event, listener) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var listeners = inst._events[event] || [];\n    listeners.push(listener);\n    inst._events[event] = listeners;\n\n    return inst;\n\n  };\n\n  /**\n   * Bind an event listener that is triggered only once.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.once = function (event, listener) {\n\n    var inst = this;\n    return this.on(event, function callback() {\n      inst.off(event, callback);\n      listener.apply(null, arguments);\n    });\n\n  };\n\n  /**\n   * Unbind all event listeners that match the provided listener function.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.off = function (event, listener) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var listeners = inst._events[event] || [];\n    var i = listeners.length;\n\n    while (i--) {\n      if (listener === listeners[i]) {\n        listeners.splice(i, 1);\n      }\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Emit all listeners in a specified event with the provided arguments.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {*} [arg1]\n   * @param {*} [arg2]\n   * @param {*} [arg3]\n   * @returns {Emitter}\n   */\n  Emitter.prototype.emit = function (event, arg1, arg2, arg3) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var listeners = inst._events[event] || [];\n    var listenersLength = listeners.length;\n    var argsLength = arguments.length - 1;\n    var i;\n\n    if (listenersLength) {\n      listeners = listeners.concat();\n      for (i = 0; i < listenersLength; i++) {\n        argsLength === 0 ? listeners[i]() :\n        argsLength === 1 ? listeners[i](arg1) :\n        argsLength === 2 ? listeners[i](arg1, arg2) :\n                            listeners[i](arg1, arg2, arg3);\n      }\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Destroy emitter instance. Basically just removes all bound listeners.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @returns {Emitter}\n   */\n  Emitter.prototype.destroy = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var eventNames = Object.keys(inst._events);\n    var i;\n\n    for (i = 0; i < eventNames.length; i++) {\n      inst._events[eventNames[i]] = null;\n    }\n\n    inst._isDestroyed = true;\n\n    return inst;\n\n  };\n\n  /**\n   * ItemAnimate\n   * ***********\n   */\n\n  /**\n   * Muuri's internal animation engine. Uses Web Animations API.\n   *\n   * @public\n   * @class\n   * @param {Item} item\n   * @param {HTMLElement} element\n   */\n  function ItemAnimate(item, element) {\n\n    var inst = this;\n    inst._item = item;\n    inst._element = element;\n    inst._animation = null;\n    inst._propsTo = null;\n    inst._isDestroyed = false;\n\n  }\n\n  /**\n   * ItemAnimate - Public prototype methods\n   * **************************************\n   */\n\n  /**\n   * Start instance's animation. Automatically stops current animation if it is\n   * running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @param {Object} propsFrom\n   * @param {Object} propsTo\n   * @param {Object} [options]\n   * @param {Number} [options.duration=300]\n   * @param {String} [options.easing='ease']\n   * @param {Function} [options.onFinish]\n   */\n  ItemAnimate.prototype.start = function (propsFrom, propsTo, options) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return;\n    }\n\n    var opts = options || {};\n    var callback = typeof opts.onFinish === typeFunction ? opts.onFinish : null;\n    var shouldStop;\n\n    // If item is being animate check if the target animation properties equal\n    // to the properties in the current animation. If they match we can just let\n    // the animation continue and be done with it (and of course change the\n    // cached callback). If the animation properties do not match we need to\n    // stop the ongoing animation.\n    if (inst._animation) {\n      shouldStop = Object.keys(propsTo).some(function (propName) {\n        return propsTo[propName] !== inst._propsTo[propName];\n      });\n      if (shouldStop) {\n        inst._animation.cancel();\n      }\n      else {\n        inst._animation.onfinish = function () {\n          inst._animation = inst._propsTo = null;\n          callback && callback();\n        };\n        return;\n      }\n    }\n\n    // Cache target props.\n    inst._propsTo = propsTo;\n\n    // Start the animation.\n    inst._animation = inst._element.animate([propsFrom, propsTo], {\n      duration: opts.duration || 300,\n      easing: opts.easing || 'ease'\n    });\n\n    // Bind animation finish callback.\n    inst._animation.onfinish = function () {\n      inst._animation = inst._propsTo = null;\n      callback && callback();\n    };\n\n    // Set the end styles.\n    setStyles(inst._element, propsTo);\n\n  };\n\n  /**\n   * Stop instance's current animation if running.\n   *\n   * @private\n   * @memberof ItemAnimate.prototype\n   * @param {Object} [currentProps]\n   */\n  ItemAnimate.prototype.stop = function (currentProps) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed && inst._animation) {\n      setStyles(inst._element, currentProps || getCurrentStyles(inst._element, inst._propsTo));\n      inst._animation.cancel();\n      inst._animation = inst._propsTo = null;\n    }\n\n  };\n\n  /**\n   * Check if the item is being animated currently.\n   *\n   * @private\n   * @memberof ItemAnimate.prototype\n   * @return {Boolean}\n   */\n  ItemAnimate.prototype.isAnimating = function () {\n\n    return !!this._animation;\n\n  };\n\n  /**\n   * Destroy the instance and stop current animation if it is running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @returns {Boolean}\n   */\n  ItemAnimate.prototype.destroy = function () {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst.stop();\n      inst._item = inst._element = null;\n      inst._isDestroyed = true;\n    }\n\n  };\n\n  /**\n   * ItemMigrate\n   * ***********\n   */\n\n  /**\n   * The migrate process handler constructor.\n   *\n   * @class\n   * @private\n   * @param {Item} item\n   */\n  function ItemMigrate(item) {\n\n    var migrate = this;\n\n    // Private props.\n    migrate._itemId = item._id;\n    migrate._isDestroyed = false;\n\n    // Public props.\n    migrate.isActive = false;\n    migrate.container = false;\n    migrate.containerDiffX = 0;\n    migrate.containerDiffY = 0;\n\n  }\n\n  /**\n   * ItemMigrate - Public prototype methods\n   * **************************************\n   */\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.destroy = function () {\n\n    var migrate = this;\n\n    if (!migrate._isDestroyed) {\n      migrate.stop(true);\n      migrate._isDestroyed = true;\n    }\n\n    return migrate;\n\n  };\n\n  /**\n   * Get Item instance.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @returns {?Item}\n   */\n  ItemMigrate.prototype.getItem = function () {\n\n    return itemInstances[this._itemId] || null;\n\n  };\n\n  /**\n   * Start the migrate process of an item.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @param {Grid} targetGrid\n   * @param {GridSingleItemQuery} position\n   * @param {HTMLElement} [container]\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.start = function (targetGrid, position, container) {\n\n    var migrate = this;\n\n    if (migrate._isDestroyed) {\n      return migrate;\n    }\n\n    var item = migrate.getItem();\n    var itemElement = item._element;\n    var isItemVisible = item.isVisible();\n    var currentGrid = item.getGrid();\n    var currentGridStn = currentGrid._settings;\n    var targetGridStn = targetGrid._settings;\n    var targetGridElement = targetGrid._element;\n    var currentIndex = currentGrid._items.indexOf(item);\n    var targetIndex = typeof position === typeNumber ? position : targetGrid._items.indexOf(targetGrid._getItem(position));\n    var targetContainer = container || body;\n    var currentContainer;\n    var offsetDiff;\n    var containerDiff;\n    var translateX;\n    var translateY;\n\n    // If we have invalid new index, let's return immediately.\n    if (targetIndex === null) {\n      return migrate;\n    }\n\n    // Normalize target index (for event data).\n    targetIndex = normalizeArrayIndex(targetGrid._items, targetIndex, true);\n\n    // Get current translateX and translateY values if needed.\n    if (item.isPositioning() || migrate.isActive || item.isReleasing()) {\n      translateX = getTranslateAsFloat(itemElement, 'x');\n      translateY = getTranslateAsFloat(itemElement, 'y');\n    }\n\n    // Abort current positioning.\n    if (item.isPositioning()) {\n      item._stopLayout(true, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Abort current migration.\n    if (migrate.isActive) {\n      translateX -= migrate.containerDiffX;\n      translateY -= migrate.containerDiffY;\n      migrate.stop(true, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Abort current release.\n    if (item.isReleasing()) {\n      translateX -= item._release.containerDiffX;\n      translateY -= item._release.containerDiffY;\n      item._release.stop(true, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Stop current visibility animations.\n    // TODO: This causes potentially layout thrashing, because we are not\n    // feeding any styles to the stop handlers.\n    currentGrid._itemShowHandler.stop(item);\n    currentGrid._itemHideHandler.stop(item);\n\n    // Destroy current drag.\n    if (item._drag) {\n      item._drag.destroy();\n    }\n\n    // Destroy current animation handlers.\n    item._animate.destroy();\n    item._animateChild.destroy();\n\n    // Process current visibility animation queue.\n    processQueue(item._visibilityQueue, true, item);\n\n    // Emit beforeSend event.\n    currentGrid._emit(evBeforeSend, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    // Emit beforeReceive event.\n    targetGrid._emit(evBeforeReceive, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    // Remove current classnames.\n    removeClass(itemElement, currentGridStn.itemClass);\n    removeClass(itemElement, currentGridStn.itemVisibleClass);\n    removeClass(itemElement, currentGridStn.itemHiddenClass);\n\n    // Add new classnames.\n    addClass(itemElement, targetGridStn.itemClass);\n    addClass(itemElement, isItemVisible ? targetGridStn.itemVisibleClass : targetGridStn.itemHiddenClass);\n\n    // Move item instance from current grid to target grid.\n    currentGrid._items.splice(currentIndex, 1);\n    insertItemsToArray(targetGrid._items, item, targetIndex);\n\n    // Update item's grid id reference.\n    item._gridId = targetGrid._id;\n\n    // Instantiate new animation controllers.\n    item._animate = new Grid.ItemAnimate(item, itemElement);\n    item._animateChild = new Grid.ItemAnimate(item, item._child);\n\n    // Get current container\n    currentContainer = itemElement.parentNode;\n\n    // Move the item inside the target container if it's different than the\n    // current container.\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(itemElement);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n      if (translateX === undefined) {\n        translateX = getTranslateAsFloat(itemElement, 'x');\n        translateY = getTranslateAsFloat(itemElement, 'y');\n      }\n      setStyles(itemElement, {transform: getTranslateString(translateX + offsetDiff.left, translateY + offsetDiff.top)});\n    }\n\n    // Update child element's styles to reflect the current visibility state.\n    item._child.removeAttribute('style');\n    if (isItemVisible) {\n      targetGrid._itemShowHandler.start(item, true);\n    }\n    else {\n      targetGrid._itemHideHandler.start(item, true);\n    }\n\n    // Update display styles.\n    setStyles(itemElement, {\n      display: isItemVisible ? 'block' : 'hidden'\n    });\n\n    // Get offset diff for the migration data.\n    containerDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n\n    // Update item's cached dimensions and sort data.\n    item._refreshDimensions()._refreshSortData();\n\n    // Create new drag handler.\n    item._drag = targetGridStn.dragEnabled ? new Grid.ItemDrag(item) : null;\n\n    // Setup migration data.\n    migrate.isActive = true;\n    migrate.container = targetContainer;\n    migrate.containerDiffX = containerDiff.left;\n    migrate.containerDiffY = containerDiff.top;\n\n    // Emit send event.\n    currentGrid._emit(evSend, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    // Emit receive event.\n    targetGrid._emit(evReceive, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    return migrate;\n\n  };\n\n  /**\n   * End the migrate process of an item. This method can be used to abort an\n   * ongoing migrate process (animation) or finish the migrate process.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @param {Boolean} [abort=false]\n   *  - Should the migration be aborted?\n   * @param {Object} [currentStyles]\n   *  - Optional current translateX and translateY styles.\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.stop = function (abort, currentStyles) {\n\n    var migrate = this;\n\n    if (migrate._isDestroyed || !migrate.isActive) {\n      return migrate;\n    }\n\n    var item = migrate.getItem();\n    var element = item._element;\n    var grid = item.getGrid();\n    var gridElement = grid._element;\n    var translateX;\n    var translateY;\n\n    if (migrate.container !== gridElement) {\n      if (!currentStyles) {\n        translateX = abort ? getTranslateAsFloat(element, 'x') - migrate.containerDiffX : item._left;\n        translateY = abort ? getTranslateAsFloat(element, 'y') - migrate.containerDiffY : item._top;\n        currentStyles = {transform: getTranslateString(translateX, translateY)};\n      }\n      gridElement.appendChild(element);\n      setStyles(element, currentStyles);\n    }\n\n    migrate.isActive = false;\n    migrate.container = null;\n    migrate.containerDiffX = 0;\n    migrate.containerDiffY = 0;\n\n    return migrate;\n\n  };\n\n  /**\n   * ItemRelease\n   * ***********\n   */\n\n  /**\n   * The release process handler constructor. Although this might seem as proper\n   * fit for the drag process this needs to be separated into it's own logic\n   * because there might be a scenario where drag is disabled, but the release\n   * process still needs to be implemented (dragging from a grid to another).\n   *\n   * @class\n   * @private\n   * @param {Item} item\n   */\n  function ItemRelease(item) {\n\n    var release = this;\n\n    // Private props.\n    release._itemId = item._id;\n    release._isDestroyed = false;\n\n    // Public props.\n    release.isActive = false;\n    release.isPositioningStarted = false;\n    release.containerDiffX = 0;\n    release.containerDiffY = 0;\n\n  }\n\n  /**\n   * ItemRelease - Public prototype methods\n   * **************************************\n   */\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.destroy = function () {\n\n    var release = this;\n\n    if (!release._isDestroyed) {\n      release.stop(true);\n      release._isDestroyed = true;\n    }\n\n    return release;\n\n  };\n\n  /**\n   * Get Item instance.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {?Item}\n   */\n  ItemRelease.prototype.getItem = function () {\n\n    return itemInstances[this._itemId] || null;\n\n  };\n\n  /**\n   * Reset public data and remove releasing class.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.reset = function () {\n\n    var release = this;\n\n    if (release._isDestroyed) {\n      return release;\n    }\n\n    var item = release.getItem();\n    release.isActive = false;\n    release.isPositioningStarted = false;\n    release.containerDiffX = 0;\n    release.containerDiffY = 0;\n    removeClass(item._element, item.getGrid()._settings.itemReleasingClass);\n\n    return release;\n\n  };\n\n  /**\n   * Start the release process of an item.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.start = function () {\n\n    var release = this;\n\n    if (release._isDestroyed || release.isActive) {\n      return release;\n    }\n\n    var item = release.getItem();\n    var grid = item.getGrid();\n\n    // Flag release as active.\n    release.isActive = true;\n\n    // Add release classname to the released element.\n    addClass(item._element, grid._settings.itemReleasingClass);\n\n    // Emit dragReleaseStart event.\n    grid._emit(evDragReleaseStart, item);\n\n    // Position the released item.\n    item._layout(false);\n\n    return release;\n\n  };\n\n  /**\n   * End the release process of an item. This method can be used to abort an\n   * ongoing release process (animation) or finish the release process.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @param {Boolean} [abort=false]\n   *  - Should the release be aborted? When true, the release end event won't be\n   *    emitted. Set to true only when you need to abort the release process\n   *    while the item is animating to it's position.\n   * @param {Object} [currentStyles]\n   *  - Optional current translateX and translateY styles.\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.stop = function (abort, currentStyles) {\n\n    var release = this;\n\n    if (release._isDestroyed || !release.isActive) {\n      return release;\n    }\n\n    var item = release.getItem();\n    var element = item._element;\n    var grid = item.getGrid();\n    var container = grid._element;\n    var containerDiffX = release.containerDiffX;\n    var containerDiffY = release.containerDiffY;\n    var translateX;\n    var translateY;\n\n    // Reset data and remove releasing classname from the element.\n    release.reset();\n\n    // If the released element is outside the grid's container element put it\n    // back there and adjust position accordingly.\n    if (element.parentNode !== container) {\n      if (!currentStyles) {\n        translateX = abort ? getTranslateAsFloat(element, 'x') - containerDiffX : item._left;\n        translateY = abort ? getTranslateAsFloat(element, 'y') - containerDiffY : item._top;\n        currentStyles = {transform: getTranslateString(translateX, translateY)};\n      }\n      container.appendChild(element);\n      setStyles(element, currentStyles);\n    }\n\n    // Emit dragReleaseEnd event.\n    if (!abort) {\n      grid._emit(evDragReleaseEnd, item);\n    }\n\n    return release;\n\n  };\n\n  /**\n   * ItemDrag\n   * ********\n   */\n\n  /**\n   * Bind Hammer touch interaction to an item.\n   *\n   * @class\n   * @private\n   * @param {Item} item\n   */\n  function ItemDrag(item) {\n\n    if (!Hammer) {\n      throw new Error('[' + namespace + '] required dependency Hammer is not defined.');\n    }\n\n    var drag = this;\n    var element = item._element;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n    var hammer;\n\n    // Start predicate.\n    var startPredicate = typeof settings.dragStartPredicate === typeFunction ?\n      settings.dragStartPredicate : ItemDrag.defaultStartPredicate;\n    var startPredicateState = startPredicateInactive;\n    var startPredicateResult;\n\n    // Protected data.\n    drag._itemId = item._id;\n    drag._gridId = grid._id;\n    drag._hammer = hammer = new Hammer.Manager(element);\n    drag._isDestroyed = false;\n    drag._isMigrating = false;\n    drag._data = {};\n\n    // Create a private drag start resolver that can be used to resolve the drag\n    // start predicate asynchronously.\n    drag._resolveStartPredicate = function (event) {\n      if (!drag._isDestroyed && startPredicateState === startPredicatePending) {\n        startPredicateState = startPredicateResolved;\n        drag.onStart(event);\n      }\n    };\n\n    // Create scroll listener.\n    drag._scrollListener = function (e) {\n      drag.onScroll(e);\n    };\n\n    // Create overlap checker function.\n    drag._checkSortOverlap = debounce(function () {\n      drag._data.isActive && drag.checkOverlap();\n    }, settings.dragSortInterval);\n\n    // Create sort predicate.\n    drag._sortPredicate = typeof settings.dragSortPredicate === typeFunction ?\n      settings.dragSortPredicate : ItemDrag.defaultSortPredicate;\n\n    // Setup item's initial drag data.\n    drag.reset();\n\n    // Add drag recognizer to hammer.\n    hammer.add(new Hammer.Pan({\n      event: 'drag',\n      pointers: 1,\n      threshold: 0,\n      direction: Hammer.DIRECTION_ALL\n    }));\n\n    // Add draginit recognizer to hammer.\n    hammer.add(new Hammer.Press({\n      event: 'draginit',\n      pointers: 1,\n      threshold: 1000,\n      time: 0\n    }));\n\n    // Configure the hammer instance.\n    if (isPlainObject(settings.dragHammerSettings)) {\n      hammer.set(settings.dragHammerSettings);\n    }\n\n    // Bind drag events.\n    hammer\n    .on('draginit dragstart dragmove', function (e) {\n\n      // Let's activate drag start predicate state.\n      if (startPredicateState === startPredicateInactive) {\n        startPredicateState = startPredicatePending;\n      }\n\n      // If predicate is pending try to resolve it.\n      if (startPredicateState === startPredicatePending) {\n        startPredicateResult = startPredicate(drag.getItem(), e);\n        if (startPredicateResult === true) {\n          startPredicateState = startPredicateResolved;\n          drag.onStart(e);\n        }\n        else if (startPredicateResult === false) {\n          startPredicateState = startPredicateRejected;\n        }\n      }\n\n      // Otherwise if predicate is resolved and drag is active, move the item.\n      else if (startPredicateState === startPredicateResolved && drag._data.isActive) {\n        drag.onMove(e);\n      }\n\n    })\n    .on('dragend dragcancel draginitup', function (e) {\n\n      // Check if the start predicate was resolved during drag.\n      var isResolved = startPredicateState === startPredicateResolved;\n\n      // Do final predicate check to allow user to unbind stuff for the current\n      // drag procedure within the predicate callback. The return value of this\n      // check will have no effect to the state of the predicate.\n      startPredicate(drag.getItem(), e);\n\n      // Reset start predicate state.\n      startPredicateState = startPredicateInactive;\n\n      // If predicate is resolved and dragging is active, call the end handler.\n      if (isResolved && drag._data.isActive) {\n        drag.onEnd(e);\n      }\n\n    });\n\n    // Prevent native link/image dragging for the item and it's ancestors.\n    element.addEventListener('dragstart', preventDefault, false);\n\n  }\n\n  /**\n   * ItemDrag - Public methods\n   * *************************\n   */\n\n  /**\n   * Default drag start predicate handler that handles anchor elements\n   * gracefully. The return value of this function defines if the drag is\n   * started, rejected or pending. When true is returned the dragging is started\n   * and when false is returned the dragging is rejected. If nothing is returned\n   * the predicate will be called again on the next drag movement.\n   *\n   * @public\n   * @memberof ItemDrag\n   * @param {Item} item\n   * @param {Object} event\n   * @param {Object} [options]\n   *   - An optional options object which can be used to pass the predicate\n   *     it's options manually. By default the predicate retrieves the options\n   *     from the grid's settings.\n   * @returns {Boolean}\n   */\n  ItemDrag.defaultStartPredicate = function (item, event, options) {\n\n    var element = item._element;\n    var predicate = item._drag._startPredicateData;\n    var config;\n    var isAnchor;\n    var href;\n    var target;\n\n    // Setup data if it is not set up yet.\n    if (!predicate) {\n      config = options || item._drag.getGrid()._settings.dragStartPredicate;\n      config = isPlainObject(config) ? config : {};\n      predicate = item._drag._startPredicateData = {\n        distance: Math.abs(config.distance) || 0,\n        delay: Math.max(config.delay, 0) || 0,\n        handle: typeof config.handle === 'string' ? config.handle : false\n      };\n    }\n\n    // Final event logic. At this stage return value does not matter anymore,\n    // the predicate is either resolved or it's not and there's nothing to do\n    // about it. Here we just reset data and if the item element is a link\n    // we follow it (if there has only been slight movement).\n    if (event.isFinal) {\n      isAnchor = element.tagName.toLowerCase() === 'a';\n      href = element.getAttribute('href');\n      target = element.getAttribute('target');\n      dragStartPredicateReset(item);\n      if (isAnchor && href && Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200) {\n        if (target && target !== '_self') {\n          global.open(href, target);\n        }\n        else {\n          global.location.href = href;\n        }\n      }\n      return;\n    }\n\n    // Find and store the handle element so we can check later on if the\n    // cursor is within the handle. If we have a handle selector let's find\n    // the corresponding element. Otherwise let's use the item element as the\n    // handle.\n    if (!predicate.handleElement) {\n      if (predicate.handle) {\n        predicate.handleElement = (event.changedPointers[0] || {}).target;\n        while (predicate.handleElement && !elementMatches(predicate.handleElement, predicate.handle)) {\n          predicate.handleElement = predicate.handleElement !== element ? predicate.handleElement.parentElement : null;\n        }\n        if (!predicate.handleElement) {\n          return false;\n        }\n      }\n      else {\n        predicate.handleElement = element;\n      }\n    }\n\n    // If delay is defined let's keep track of the latest event and initiate\n    // delay if it has not been done yet.\n    if (predicate.delay) {\n      predicate.event = event;\n      if (!predicate.delayTimer) {\n        predicate.delayTimer = global.setTimeout(function () {\n          predicate.delay = 0;\n          if (dragStartPredicateResolve(item, predicate.event)) {\n            item._drag._resolveStartPredicate(predicate.event);\n            dragStartPredicateReset(item);\n          }\n        }, predicate.delay);\n      }\n    }\n\n    return dragStartPredicateResolve(item, event);\n\n  };\n\n  /**\n   * Default drag sort predicate.\n   *\n   * @public\n   * @memberof ItemDrag\n   * @param {Item} item\n   * @param {Object} event\n   * @returns {(Boolean|DragSortCommand)}\n   *   - Returns false if no valid index was found. Otherwise returns drag sort\n   *     command.\n   */\n  ItemDrag.defaultSortPredicate = function (item) {\n\n    var drag = item._drag;\n    var dragData = drag._data;\n    var rootGrid = drag.getGrid();\n    var settings = rootGrid._settings;\n    var config = settings.dragSortPredicate || {};\n    var sortThreshold = config.threshold || 50;\n    var sortAction = config.action || 'move';\n    var itemRect = {\n      width: item._width,\n      height: item._height,\n      left: dragData.elementClientX,\n      top: dragData.elementClientY\n    };\n    var grid = getTargetGrid(item, rootGrid, itemRect, sortThreshold);\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = -1;\n    var matchIndex;\n    var hasValidTargets;\n    var target;\n    var score;\n    var i;\n\n    // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n    if (!grid) {\n      return false;\n    }\n\n    // If item is moved within it's originating grid adjust item's left and top\n    // props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n    if (grid === rootGrid) {\n      itemRect.left = dragData.gridX + item._margin.left;\n      itemRect.top = dragData.gridY + item._margin.top;\n    }\n    else {\n      gridOffsetLeft = grid._left + grid._border.left;\n      gridOffsetTop = grid._top + grid._border.top;\n    }\n\n    // Loop through the target grid items and try to find the best match.\n    for (i = 0; i < grid._items.length; i++) {\n\n      target = grid._items[i];\n\n      // If the target item is not active or the target item is the dragged item\n      // let's skip to the next item.\n      if (!target._isActive || target === item) {\n        continue;\n      }\n\n      // Mark the grid as having valid target items.\n      hasValidTargets = true;\n\n      // Calculate the target's overlap score with the dragged item.\n      score = getRectOverlapScore(itemRect, {\n        width: target._width,\n        height: target._height,\n        left: target._left + target._margin.left + gridOffsetLeft,\n        top: target._top + target._margin.top + gridOffsetTop\n      });\n\n      // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n\n    }\n\n    // If there is no valid match and the item is being moved into another grid.\n    if (matchScore < sortThreshold && item.getGrid() !== grid) {\n      matchIndex = hasValidTargets ? -1 : 0;\n      matchScore = Infinity;\n    }\n\n    // Check if the best match overlaps enough to justify a placement switch.\n    if (matchScore >= sortThreshold) {\n      return {\n        grid: grid,\n        index: matchIndex,\n        action: sortAction\n      };\n    }\n\n    return false;\n\n  };\n\n  /**\n   * ItemDrag - Public prototype methods\n   * ***********************************\n   */\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.destroy = function () {\n\n    var drag = this;\n\n    if (!drag._isDestroyed) {\n      drag.stop();\n      drag._hammer.destroy();\n      drag.getItem()._element.removeEventListener('dragstart', preventDefault, false);\n      drag._isDestroyed = true;\n    }\n\n    return drag;\n\n  };\n\n  /**\n   * Get Item instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {?Item}\n   */\n  ItemDrag.prototype.getItem = function () {\n\n    return itemInstances[this._itemId] || null;\n\n  };\n\n  /**\n   * Get Grid instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {?Grid}\n   */\n  ItemDrag.prototype.getGrid = function () {\n\n    return gridInstances[this._gridId] || null;\n\n  };\n\n  /**\n   * Setup/reset drag data.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.reset = function () {\n\n    var drag = this;\n    var dragData = drag._data;\n\n    // Is item being dragged?\n    dragData.isActive = false;\n\n    // The dragged item's container element.\n    dragData.container = null;\n\n    // The dragged item's containing block.\n    dragData.containingBlock = null;\n\n    // Hammer event data.\n    dragData.startEvent = null;\n    dragData.currentEvent = null;\n\n    // All the elements which need to be listened for scroll events during\n    // dragging.\n    dragData.scrollers = [];\n\n    // The current translateX/translateY position.\n    dragData.left = 0;\n    dragData.top = 0;\n\n    // Dragged element's current position within the grid.\n    dragData.gridX = 0;\n    dragData.gridY = 0;\n\n    // Dragged element's current offset from window's northwest corner. Does\n    // not account for element's margins.\n    dragData.elementClientX = 0;\n    dragData.elementClientY = 0;\n\n    // Offset difference between the dragged element's temporary drag\n    // container and it's original container.\n    dragData.containerDiffX = 0;\n    dragData.containerDiffY = 0;\n\n    return drag;\n\n  };\n\n  /**\n   * Bind drag scroll handlers to all scrollable ancestor elements of the\n   * dragged element and the drag container element.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.bindScrollListeners = function () {\n\n    var drag = this;\n    var gridContainer = drag.getGrid()._element;\n    var dragContainer = drag._data.container;\n    var scrollers = getScrollParents(drag.getItem()._element);\n    var i;\n\n    // If drag container is defined and it's not the same element as grid\n    // container then we need to add the grid container and it's scroll parents\n    // to the elements which are going to be listener for scroll events.\n    if (dragContainer !== gridContainer) {\n      scrollers = arrayUnique(scrollers.concat(gridContainer).concat(getScrollParents(gridContainer)));\n    }\n\n    // Bind scroll listeners.\n    for (i = 0; i < scrollers.length; i++) {\n      scrollers[i].addEventListener('scroll', drag._scrollListener);\n    }\n\n    // Save scrollers to drag data.\n    drag._data.scrollers = scrollers;\n\n    return drag;\n\n  };\n\n  /**\n   * Unbind currently bound drag scroll handlers from all scrollable ancestor\n   * elements of the dragged element and the drag container element.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.unbindScrollListeners = function () {\n\n    var drag = this;\n    var dragData = drag._data;\n    var scrollers = dragData.scrollers;\n    var i;\n\n    for (i = 0; i < scrollers.length; i++) {\n      scrollers[i].removeEventListener('scroll', drag._scrollListener);\n    }\n\n    dragData.scrollers = [];\n\n    return drag;\n\n  };\n\n  /**\n   * Check (during drag) if an item is overlapping other items and based on\n   * the configuration layout the items.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.checkOverlap = function () {\n\n    var drag = this;\n    var item = drag.getItem();\n    var result = drag._sortPredicate(item, drag._data.currentEvent);\n    var currentGrid;\n    var currentIndex;\n    var targetGrid;\n    var targetIndex;\n    var sortAction;\n    var isMigration;\n\n    // Let's make sure the result object has a valid index before going further.\n    if (!isPlainObject(result) || typeof result.index !== typeNumber) {\n      return drag;\n    }\n\n    currentGrid = item.getGrid();\n    targetGrid = result.grid || currentGrid;\n    isMigration = currentGrid !== targetGrid;\n    currentIndex = currentGrid._items.indexOf(item);\n    targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration);\n    sortAction = result.action === 'swap' ? 'swap' : 'move';\n\n    // If the item was moved within it's current grid.\n    if (!isMigration) {\n\n      // Make sure the target index is not the current index.\n      if (currentIndex !== targetIndex) {\n\n        // Do the sort.\n        (sortAction === 'swap' ? arraySwap : arrayMove)(currentGrid._items, currentIndex, targetIndex);\n\n        // Emit move event.\n        currentGrid._emit(evMove, {\n          item: item,\n          fromIndex: currentIndex,\n          toIndex: targetIndex,\n          action: sortAction\n        });\n\n        // Layout the grid.\n        currentGrid.layout();\n\n      }\n\n    }\n\n    // If the item was moved to another grid.\n    else {\n\n      // Emit beforeSend event.\n      currentGrid._emit(evBeforeSend, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Emit beforeReceive event.\n      targetGrid._emit(evBeforeReceive, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Update item's grid id reference.\n      item._gridId = targetGrid._id;\n\n      // Update drag instances's migrating indicator.\n      drag._isMigrating = item._gridId !== drag._gridId;\n\n      // Move item instance from current grid to target grid.\n      currentGrid._items.splice(currentIndex, 1);\n      insertItemsToArray(targetGrid._items, item, targetIndex);\n\n      // Set sort data as null, which is an indicator for the item comparison\n      // function that the sort data of this specific item should be fetched\n      // lazily.\n      item._sortData = null;\n\n      // Emit send event.\n      currentGrid._emit(evSend, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Emit receive event.\n      targetGrid._emit(evReceive, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Layout both grids.\n      currentGrid.layout();\n      targetGrid.layout();\n\n    }\n\n    return drag;\n\n  };\n\n  /**\n   * If item is dragged into another grid, finish the migration process\n   * gracefully.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.finishMigration = function () {\n\n    var drag = this;\n    var item = drag.getItem();\n    var release = item._release;\n    var element = item._element;\n    var targetGrid = item.getGrid();\n    var targetGridElement = targetGrid._element;\n    var targetSettings = targetGrid._settings;\n    var targetContainer = targetSettings.dragContainer || targetGridElement;\n    var currentSettings = drag.getGrid()._settings;\n    var currentContainer = element.parentNode;\n    var translateX;\n    var translateY;\n    var offsetDiff;\n\n    // Destroy current drag. Note that we need to set the migrating flag to\n    // false first, because otherwise we create an infinite loop between this\n    // and the drag.stop() method.\n    drag._isMigrating = false;\n    drag.destroy();\n\n    // Destroy current animation handlers.\n    item._animate.destroy();\n    item._animateChild.destroy();\n\n    // Remove current classnames.\n    removeClass(element, currentSettings.itemClass);\n    removeClass(element, currentSettings.itemVisibleClass);\n    removeClass(element, currentSettings.itemHiddenClass);\n\n    // Add new classnames.\n    addClass(element, targetSettings.itemClass);\n    addClass(element, targetSettings.itemVisibleClass);\n\n    // Instantiate new animation controllers.\n    item._animate = new Grid.ItemAnimate(item, element);\n    item._animateChild = new Grid.ItemAnimate(item, item._child);\n\n    // Move the item inside the target container if it's different than the\n    // current container.\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n      translateX = getTranslateAsFloat(element, 'x') - offsetDiff.left;\n      translateY = getTranslateAsFloat(element, 'y') - offsetDiff.top;\n    }\n\n    // Update item's cached dimensions and sort data.\n    item._refreshDimensions()._refreshSortData();\n\n    // Calculate the offset difference between target's drag container (if any)\n    // and actual grid container element. We save it later for the release\n    // process.\n    offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n    release.containerDiffX = offsetDiff.left;\n    release.containerDiffY = offsetDiff.top;\n\n    // Recreate item's drag handler.\n    item._drag = targetSettings.dragEnabled ? new Grid.ItemDrag(item) : null;\n\n    // Adjust the position of the item element if it was moved from a container\n    // to another.\n    if (targetContainer !== currentContainer) {\n      setStyles(element, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Update child element's styles to reflect the current visibility state.\n    item._child.removeAttribute('style');\n    targetGrid._itemShowHandler.start(item, true);\n\n    // Start the release.\n    release.start();\n\n    return drag;\n\n  };\n\n  /**\n   * cancel move/scroll event raf loop action.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.cancelRafLoop = function () {\n\n    var id = this.getItem()._id;\n\n    rafLoop.cancel(rafQueueScroll, id);\n    rafLoop.cancel(rafQueueMove, id);\n\n    return this;\n\n  };\n\n  /**\n   * Abort dragging and reset drag data.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.stop = function () {\n\n    var drag = this;\n    var dragData = drag._data;\n    var item = drag.getItem();\n    var element = item._element;\n    var grid = drag.getGrid();\n\n    if (!dragData.isActive) {\n      return drag;\n    }\n\n    // If the item is being dropped into another grid, finish it up and return\n    // immediately.\n    if (drag._isMigrating) {\n      return drag.finishMigration(dragData.currentEvent);\n    }\n\n    // Cancel raf loop actions.\n    drag.cancelRafLoop();\n\n    // Remove scroll listeners.\n    drag.unbindScrollListeners();\n\n    // Cancel overlap check.\n    drag._checkSortOverlap('cancel');\n\n    // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n      setStyles(element, {transform: getTranslateString(dragData.gridX, dragData.gridY)});\n    }\n\n    // Remove dragging class.\n    removeClass(element, grid._settings.itemDraggingClass);\n\n    // Reset drag data.\n    drag.reset();\n\n    return drag;\n\n  };\n\n  /**\n   * Drag start handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onStart = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n\n    // If item is not active, don't start the drag.\n    if (!item._isActive) {\n      return drag;\n    }\n\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var dragData = drag._data;\n    var release = item._release;\n    var migrate = item._migrate;\n    var gridContainer = grid._element;\n    var dragContainer = settings.dragContainer || gridContainer;\n    var containingBlock = getContainingBlock(dragContainer, true);\n    var offsetDiff = dragContainer !== gridContainer ? getOffsetDiff(containingBlock, gridContainer) : 0;\n    var currentLeft = getTranslateAsFloat(element, 'x');\n    var currentTop = getTranslateAsFloat(element, 'y');\n    var elementRect = element.getBoundingClientRect();\n\n    // Stop current positioning animation.\n    if (item.isPositioning()) {\n      item._stopLayout(true, {transform: getTranslateString(currentLeft, currentTop)});\n    }\n\n    // Stop current migration animation.\n    if (migrate.isActive) {\n      currentLeft -= migrate.containerDiffX;\n      currentTop -= migrate.containerDiffY;\n      migrate.stop(true, {transform: getTranslateString(currentLeft, currentTop)});\n    }\n\n    // If item is being released reset release data.\n    if (item.isReleasing()) {\n      release.reset();\n    }\n\n    // Setup drag data.\n    dragData.isActive = true;\n    dragData.startEvent = dragData.currentEvent = event;\n    dragData.container = dragContainer;\n    dragData.containingBlock = containingBlock;\n    dragData.elementClientX = elementRect.left;\n    dragData.elementClientY = elementRect.top;\n    dragData.left = dragData.gridX = currentLeft;\n    dragData.top = dragData.gridY = currentTop;\n\n    // Emit dragInit event.\n    grid._emit(evDragInit, item, event);\n\n    // If a specific drag container is set and it is different from the\n    // grid's container element we need to cast some extra spells.\n    if (dragContainer !== gridContainer) {\n\n      // Store the container offset diffs to drag data.\n      dragData.containerDiffX = offsetDiff.left;\n      dragData.containerDiffY = offsetDiff.top;\n\n      // If the dragged element is a child of the drag container all we need to\n      // do is setup the relative drag position data.\n      if (element.parentNode === dragContainer) {\n        dragData.gridX = currentLeft - dragData.containerDiffX;\n        dragData.gridY = currentTop - dragData.containerDiffY;\n      }\n\n      // Otherwise we need to append the element inside the correct container,\n      // setup the actual drag position data and adjust the element's translate\n      // values to account for the DOM position shift.\n      else {\n        dragData.left = currentLeft + dragData.containerDiffX;\n        dragData.top = currentTop + dragData.containerDiffY;\n        dragContainer.appendChild(element);\n        setStyles(element, {transform: getTranslateString(dragData.left, dragData.top)});\n      }\n\n    }\n\n    // Set drag class and bind scrollers.\n    addClass(element, settings.itemDraggingClass);\n    drag.bindScrollListeners();\n\n    // Emit dragStart event.\n    grid._emit(evDragStart, item, event);\n\n    return drag;\n\n  };\n\n  /**\n   * Drag move handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onMove = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      return drag.stop();\n    }\n\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var dragData = drag._data;\n    var axis = settings.dragAxis;\n    var xDiff = event.deltaX - dragData.currentEvent.deltaX;\n    var yDiff = event.deltaY - dragData.currentEvent.deltaY;\n\n    rafLoop.add(rafQueueMove, item._id, function () {\n\n      // Update current event.\n      dragData.currentEvent = event;\n\n      // Update horizontal position data.\n      if (axis !== 'y') {\n        dragData.left += xDiff;\n        dragData.gridX += xDiff;\n        dragData.elementClientX += xDiff;\n      }\n\n      // Update vertical position data.\n      if (axis !== 'x') {\n        dragData.top += yDiff;\n        dragData.gridY += yDiff;\n        dragData.elementClientY += yDiff;\n      }\n\n      // Overlap handling.\n      settings.dragSort && drag._checkSortOverlap();\n\n    }, function () {\n\n      // Update element's translateX/Y values.\n      setStyles(element, {transform: getTranslateString(dragData.left, dragData.top)});\n\n      // Emit dragMove event.\n      grid._emit(evDragMove, item, event);\n\n    });\n\n    return drag;\n\n  };\n\n  /**\n   * Drag scroll handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onScroll = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var axis = settings.dragAxis;\n    var dragData = drag._data;\n    var gridContainer = grid._element;\n    var elementRect;\n    var xDiff;\n    var yDiff;\n    var offsetDiff;\n\n    rafLoop.add(rafQueueScroll, item._id, function () {\n\n      // Calculate element's rect and x/y diff.\n      elementRect = element.getBoundingClientRect();\n      xDiff = dragData.elementClientX - elementRect.left;\n      yDiff = dragData.elementClientY - elementRect.top;\n\n      // Update container diff.\n      if (dragData.container !== gridContainer) {\n        offsetDiff = getOffsetDiff(dragData.containingBlock, gridContainer);\n        dragData.containerDiffX = offsetDiff.left;\n        dragData.containerDiffY = offsetDiff.top;\n      }\n\n      // Update horizontal position data.\n      if (axis !== 'y') {\n        dragData.left += xDiff;\n        dragData.gridX = dragData.left - dragData.containerDiffX;\n      }\n\n      // Update vertical position data.\n      if (axis !== 'x') {\n        dragData.top += yDiff;\n        dragData.gridY = dragData.top - dragData.containerDiffY;\n      }\n\n      // Overlap handling.\n      settings.dragSort && drag._checkSortOverlap();\n\n    }, function () {\n\n      // Update element's translateX/Y values.\n      setStyles(element, {transform: getTranslateString(dragData.left, dragData.top)});\n\n      // Emit dragScroll event.\n      grid._emit(evDragScroll, item, event);\n\n    });\n\n    return drag;\n\n  };\n\n  /**\n   * Drag end handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onEnd = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var dragData = drag._data;\n    var release = item._release;\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      return drag.stop();\n    }\n\n    // Cancel raf loop actions.\n    drag.cancelRafLoop();\n\n    // Finish currently queued overlap check.\n    settings.dragSort && drag._checkSortOverlap('finish');\n\n    // Remove scroll listeners.\n    drag.unbindScrollListeners();\n\n    // Setup release data.\n    release.containerDiffX = dragData.containerDiffX;\n    release.containerDiffY = dragData.containerDiffY;\n\n    // Reset drag data.\n    drag.reset();\n\n    // Remove drag classname from element.\n    removeClass(element, settings.itemDraggingClass);\n\n    // Emit dragEnd event.\n    grid._emit(evDragEnd, item, event);\n\n    // Finish up the migration process or start the release process.\n    drag._isMigrating ? drag.finishMigration() : release.start();\n\n    return drag;\n\n  };\n\n  /**\n   * Helpers - Generic\n   * *****************\n   */\n\n  /**\n   * Normalize array index. Basically this function makes sure that the provided\n   * array index is within the bounds of the provided array and also transforms\n   * negative index to the matching positive index.\n   *\n   * @private\n   * @param {Array} array\n   * @param {Number} index\n   * @param {Boolean} isMigration\n   */\n  function normalizeArrayIndex(array, index, isMigration) {\n\n    var length = array.length;\n    var maxIndex = Math.max(0, isMigration ? length : length - 1);\n\n    return index > maxIndex ? maxIndex :\n      index < 0 ? Math.max(maxIndex + index + 1, 0) :\n      index;\n\n  }\n\n  /**\n   * Swap array items.\n   *\n   * @private\n   * @param {Array} array\n   * @param {Number} index\n   *   - Index (positive or negative) of the item that will be swapped.\n   * @param {Number} withIndex\n   *   - Index (positive or negative) of the other item that will be swapped.\n   */\n  function arraySwap(array, index, withIndex) {\n\n    // Make sure the array has two or more items.\n    if (array.length < 2) {\n      return;\n    }\n\n    // Normalize the indices.\n    var indexA = normalizeArrayIndex(array, index);\n    var indexB = normalizeArrayIndex(array, withIndex);\n    var temp;\n\n    // Swap the items.\n    if (indexA !== indexB) {\n      temp = array[indexA];\n      array[indexA] = array[indexB];\n      array[indexB] = temp;\n    }\n\n  }\n\n  /**\n   * Move array item to another index.\n   *\n   * @private\n   * @param {Array} array\n   * @param {Number} fromIndex\n   *   - Index (positive or negative) of the item that will be moved.\n   * @param {Number} toIndex\n   *   - Index (positive or negative) where the item should be moved to.\n   */\n  function arrayMove(array, fromIndex, toIndex) {\n\n    // Make sure the array has two or more items.\n    if (array.length < 2) {\n      return;\n    }\n\n    // Normalize the indices.\n    var from = normalizeArrayIndex(array, fromIndex);\n    var to = normalizeArrayIndex(array, toIndex);\n\n    // Add target item to the new position.\n    if (from !== to) {\n      array.splice(to, 0, array.splice(from, 1)[0]);\n    }\n\n  }\n\n  /**\n   * Returns a new duplicate free version of the provided array.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Array}\n   */\n  function arrayUnique(array) {\n\n    var ret = [];\n    var len = array.length;\n    var i;\n\n    if (len) {\n      ret[0] = array[0];\n      for (i = 1; i < len; i++) {\n        if (ret.indexOf(array[i]) < 0) {\n          ret.push(array[i]);\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Check if a value is a node list\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isNodeList(val) {\n\n    var type = Object.prototype.toString.call(val);\n    return type === '[object HTMLCollection]' || type === '[object NodeList]';\n\n  }\n\n  /**\n   * Merge two objects recursively (deep merge). The source object's properties\n   * are merged to the target object.\n   *\n   * @private\n   * @param {Object} target\n   *   - The target object.\n   * @param {Object} source\n   *   - The source object.\n   * @returns {Object} Returns the target object.\n   */\n  function mergeObjects(target, source) {\n\n    // Loop through the surce object's props.\n    Object.keys(source).forEach(function (propName) {\n\n      var isObject = isPlainObject(source[propName]);\n\n      // If target and source values are both objects, merge the objects and\n      // assign the merged value to the target property.\n      if (isPlainObject(target[propName]) && isObject) {\n        target[propName] = mergeObjects({}, target[propName]);\n        target[propName] = mergeObjects(target[propName], source[propName]);\n      }\n\n      // Otherwise set the source object's value to target object and make sure\n      // that object and array values are cloned and directly assigned.\n      else {\n        target[propName] = isObject ? mergeObjects({}, source[propName]) :\n          Array.isArray(source[propName]) ? source[propName].concat() :\n          source[propName];\n      }\n\n    });\n\n    return target;\n\n  }\n\n  /**\n   * Insert an item or an array of items to array to a specified index. Mutates\n   * the array. The index can be negative in which case the items will be added\n   * to the end of the array.\n   *\n   * @private\n   * @param {Array} array\n   * @param {*} items\n   * @param {Number} [index=-1]\n   */\n  function insertItemsToArray(array, items, index) {\n\n    var targetIndex = typeof index === typeNumber ? index : -1;\n    array.splice.apply(array, [targetIndex < 0 ? array.length - targetIndex + 1 : targetIndex, 0].concat(items));\n\n  }\n\n  /**\n   * Returns a function, that, as long as it continues to be invoked, will not\n   * be triggered. The function will be called after it stops being called for\n   * N milliseconds. The returned function accepts one argument which, when\n   * being \"finish\", calls the debounced function immediately if it is currently\n   * waiting to be called, and when being \"cancel\" cancels the currently queued\n   * function call.\n   *\n   * @private\n   * @param {Function} fn\n   * @param {Number} wait\n   * @returns {Function}\n   */\n  function debounce(fn, wait) {\n\n    var timeout;\n    var actionCancel = 'cancel';\n    var actionFinish = 'finish';\n\n    return wait > 0 ? function (action) {\n\n      if (timeout !== undefined) {\n        timeout = global.clearTimeout(timeout);\n        if (action === actionFinish) {\n          fn();\n        }\n      }\n\n      if (action !== actionCancel && action !== actionFinish) {\n        timeout = global.setTimeout(function () {\n          timeout = undefined;\n          fn();\n        }, wait);\n      }\n\n    } : function (action) {\n\n      if (action !== actionCancel) {\n        fn();\n      }\n\n    };\n\n  }\n\n  /**\n   * Returns a raf loop queue system that allows pushing callbacks to either\n   * the read queue or the write queue.\n   *\n   * @private\n   * @returns {Object}\n   */\n  function createRafLoop() {\n\n    var nextTick = null;\n    var queue = [];\n    var map = {};\n    var raf = (global.requestAnimationFrame\n      || global.webkitRequestAnimationFrame\n      || global.mozRequestAnimationFrame\n      || global.msRequestAnimationFrame\n      || function (cb) {\n        return global.setTimeout(cb, 16);\n      }\n    ).bind(global);\n\n    function add(type, id, readCallback, writeCallback) {\n\n      // First, let's check if an item has been added to the queues with the\n      // same id and remove it.\n      var currentIndex = queue.indexOf(type + id);\n      if (currentIndex > -1) {\n        queue.splice(currentIndex, 1);\n      }\n\n      // Add all move/scroll event callbacks to the beginning of the queue\n      // and other callbacks to the end of the queue.\n      type === rafQueueMove || type === rafQueueScroll ? queue.unshift(type + id) : queue.push(type + id);\n      map[type + id] = [readCallback, writeCallback];\n\n      // Finally, let's kickstart the next tick if it is not running yet.\n      !nextTick && (nextTick = raf(flush));\n\n    }\n\n    function cancel(type, id) {\n\n      // Let's check if an item has been added to the queue with the id and\n      // if so -> remove it.\n      var currentIndex = queue.indexOf(type + id);\n      if (currentIndex > -1) {\n        queue.splice(currentIndex, 1);\n        map[type + id] = undefined;\n      }\n\n    }\n\n    function flush() {\n\n      var maxBatchSize = +Grid._maxRafBatchSize || 100;\n      var batch = queue.splice(0, Math.min(maxBatchSize, queue.length));\n      var batchMap = {};\n      var i;\n\n      // Reset ticker.\n      nextTick = null;\n\n      // Create batch map and clear map items.\n      for (i = 0; i < batch.length; i++) {\n        batchMap[batch[i]] = map[batch[i]];\n        map[batch[i]] = undefined;\n      }\n\n      // Process read callbacks.\n      for (i = 0; i < batch.length; i++) {\n        batchMap[batch[i]][0]();\n      }\n\n      // Process write callbacks.\n      for (i = 0; i < batch.length; i++) {\n        batchMap[batch[i]][1]();\n      }\n\n      // Restart the ticker if needed.\n      if (!nextTick && queue.length) {\n        nextTick = raf(flush);\n      }\n\n    }\n\n    return {\n      add: add,\n      cancel: cancel\n    };\n\n  }\n\n  /**\n   * Helpers - DOM utils\n   * *******************\n   */\n\n  /**\n   * Transforms a camel case style property to kebab case style property.\n   *\n   * @private\n   * @param {String} string\n   * @returns {String}\n   */\n  function getStyleName(string) {\n\n    return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(element, style) {\n\n    return global.getComputedStyle(element, null).getPropertyValue(style === 'transform' ? transform.styleName || style : style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {HTMLElement} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return parseFloat(getStyle(el, style)) || 0;\n\n  }\n\n  /**\n   * Returns the element's computed translateX/Y value as a float. Assumes that\n   * the translate value is defined as pixels.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} axis\n   *   - \"x\" or \"y\".\n   * @returns {Number}\n   */\n  function getTranslateAsFloat(element, axis) {\n\n    return parseFloat((getStyle(element, 'transform') || '').replace('matrix(', '').split(',')[axis === 'x' ? 4 : 5]) || 0;\n\n  }\n\n  /**\n   * Transform translateX and translateY value into CSS transform style\n   * property's value.\n   *\n   * @private\n   * @param {Number} translateX\n   * @param {Number} translateY\n   * @returns {String}\n   */\n  function getTranslateString(translateX, translateY) {\n\n    return 'translateX(' + translateX + 'px) translateY(' + translateY + 'px)';\n\n  }\n\n  /**\n   * Get current values of the provided styles definition object.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {Object}\n   */\n  function getCurrentStyles(element, styles) {\n\n    var current = {};\n    var keys = Object.keys(styles);\n    var i;\n\n    for (i = 0; i < keys.length; i++) {\n      current[keys[i]] = getStyle(element, getStyleName(keys[i]));\n    }\n\n    return current;\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   */\n  function setStyles(element, styles) {\n\n    var props = Object.keys(styles);\n    var i;\n\n    for (i = 0; i < props.length; i++) {\n      element.style[props[i] === 'transform' && transform ? transform.propName : props[i]] = styles[props[i]];\n    }\n\n  }\n\n  /**\n   * Add class to an element.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} className\n   */\n  function addClass(element, className) {\n\n    if (element.classList) {\n      element.classList.add(className);\n    }\n    else if (!elementMatches(element, '.' + className)) {\n      element.className += ' ' + className;\n    }\n\n  }\n\n  /**\n   * Remove class name from an element.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} className\n   */\n  function removeClass(element, className) {\n\n    if (element.classList) {\n      element.classList.remove(className);\n    }\n    else if (elementMatches(element, '.' + className)) {\n      element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();\n    }\n\n  }\n\n  /**\n   * Convert nodeList to array.\n   *\n   * @private\n   * @param {NodeList} nodeList\n   * @returns {HTMLElement[]}\n   */\n  function nodeListToArray(nodeList) {\n\n    return [].slice.call(nodeList);\n\n  }\n\n  /**\n   * Checks the supported element.matches() method and returns a function that\n   * can be used to call the supported method.\n   *\n   * @private\n   * @returns {Function}\n   */\n  function getSupportedElementMatches() {\n\n    var p = Element.prototype;\n    var fn = p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;\n\n    return function (el, selector) {\n      return fn.call(el, selector);\n    };\n\n  }\n\n  /**\n   * Returns the supported style property's prefix, property name and style name\n   * or null if the style property is not supported. This is used for getting\n   * the supported transform.\n   *\n   * @private\n   * @param {String} style\n   * @returns {?Object}\n   */\n  function getSupportedStyle(style) {\n\n    var styleCap = style.charAt(0).toUpperCase() + style.slice(1);\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    var prefix;\n    var propName;\n    var i;\n\n    for (i = 0; i < prefixes.length; i++) {\n      prefix = prefixes[i];\n      propName = prefix ? prefix + styleCap : style;\n      if (docElem.style[propName] !== undefined) {\n        prefix = prefix.toLowerCase();\n        return {\n          prefix: prefix,\n          propName: propName,\n          styleName: prefix ? '-' + prefix + '-' + style : style\n        };\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Calculate the offset difference two elements.\n   *\n   * @private\n   * @param {HTMLElement} elemA\n   * @param {HTMLElement} elemB\n   * @param {Boolean} [compareContainingBlocks=false]\n   *   - When this is set to true the containing blocks of the provided elements\n   *     will be used for calculating the difference. Otherwise the provided\n   *     elements will be compared directly.\n   * @returns {Object}\n   */\n  function getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n\n    if (elemA === elemB) {\n      return {\n        left: 0,\n        top: 0\n      };\n    }\n\n    if (compareContainingBlocks) {\n      elemA = getContainingBlock(elemA, true);\n      elemB = getContainingBlock(elemB, true);\n    }\n\n    var aOffset = getOffset(elemA, true);\n    var bOffset = getOffset(elemB, true);\n\n    return {\n      left: bOffset.left - aOffset.left,\n      top: bOffset.top - aOffset.top\n    };\n\n  }\n\n  /**\n   * Returns the element's document offset, which in practice means the vertical\n   * and horizontal distance between the element's northwest corner and the\n   * document's northwest corner.\n   *\n   * @private\n   * @param {(Document|Element|Window)} element\n   * @param {Boolean} [excludeElementBorders=false]\n   * @returns {Offset}\n   */\n  function getOffset(element, excludeElementBorders) {\n\n    var rect;\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (element === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = global.pageXOffset || 0;\n    ret.top = global.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (element.self === global.self) {\n      return ret;\n    }\n\n    // Add element's client rects to the offsets.\n    rect = element.getBoundingClientRect();\n    ret.left += rect.left;\n    ret.top += rect.top;\n\n    // Exclude element's borders from the offset if needed.\n    if (excludeElementBorders) {\n      ret.left += getStyleAsFloat(element, 'border-left-width');\n      ret.top += getStyleAsFloat(element, 'border-top-width');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an aabsolute positioned element's containing block, which is\n   * considered to be the closest ancestor element that the target element's\n   * positioning is relative to. Disclaimer: this only works as intended for\n   * abolute positioned elements.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {Boolean} [isParent=false]\n   *   - When this is set to true the containing block checking is started from\n   *     the provided element. Otherwise the checking is started from the\n   *     provided element's parent element.\n   * @returns {(Document|Element)}\n   */\n  function getContainingBlock(element, isParent) {\n\n    // As long as the containing block is an element, static and not\n    // transformed, try to get the element's parent element and fallback to\n    // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n    var ret = (isParent ? element : element.parentElement) || doc;\n    while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n      ret = ret.parentElement || doc;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Get element's scroll parents.\n   *\n   * Borrowed from jQuery UI library (and heavily modified):\n   * https://github.com/jquery/jquery-ui/blob/63448148a217da7e64c04b21a04982f0d6\n   * 4aabaa/ui/scroll-parent.js\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @returns {HTMLElement[]}\n   */\n  function getScrollParents(element) {\n\n    var ret = [];\n    var overflowRegex = /(auto|scroll)/;\n    var parent = element.parentNode;\n\n    // If transformed elements leak fixed elements.\n    if (transformLeaksFixed) {\n\n      // If the element is fixed it can not have any scroll parents.\n      if (getStyle(element, 'position') === 'fixed') {\n        return ret;\n      }\n\n      // Find scroll parents.\n      while (parent && parent !== doc && parent !== docElem) {\n        if (overflowRegex.test(getStyle(parent, 'overflow') + getStyle(parent, 'overflow-y') + getStyle(parent, 'overflow-x'))) {\n          ret.push(parent);\n        }\n        parent = getStyle(parent, 'position') === 'fixed' ? null : parent.parentNode;\n      }\n\n      // If parent is not fixed element, add window object as the last scroll\n      // parent.\n      parent !== null && ret.push(global);\n\n    }\n    // If fixed elements behave as defined in the W3C specification.\n    else {\n\n      // Find scroll parents.\n      while (parent && parent !== doc) {\n\n        // If the currently looped element is fixed ignore all parents that are\n        // not transformed.\n        if (getStyle(element, 'position') === 'fixed' && !isTransformed(parent)) {\n          parent = parent.parentNode;\n          continue;\n        }\n\n        // Add the parent element to return items if it is scrollable.\n        if (overflowRegex.test(getStyle(parent, 'overflow') + getStyle(parent, 'overflow-y') + getStyle(parent, 'overflow-x'))) {\n          ret.push(parent);\n        }\n\n        // Update element and parent references.\n        element = parent;\n        parent = parent.parentNode;\n\n      }\n\n      // If the last item is the root element, replace it with the global\n      // object (window). The root element scroll is propagated to the window.\n      if (ret[ret.length - 1] === docElem) {\n        ret[ret.length - 1] = global;\n      }\n\n      // Otherwise add global object (window) as the last scroll parent.\n      else {\n        ret.push(global);\n      }\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox). So we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * Borrowed from Mezr (v0.6.1):\n   * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L607\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!transform) {\n      return true;\n    }\n\n    var elems = [0, 1].map(function (elem, isInner) {\n      elem = doc.createElement('div');\n      setStyles(elem, {\n        position: isInner ? 'fixed' : 'absolute',\n        display: 'block',\n        visibility: 'hidden',\n        left: isInner ? '0px' : '1px',\n        transform: 'none'\n      });\n      return elem;\n    });\n    var outer = body.appendChild(elems[0]);\n    var inner = outer.appendChild(elems[1]);\n    var left = inner.getBoundingClientRect().left;\n    setStyles(outer, {transform: 'scale(1)'});\n    var isLeaking = left === inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return isLeaking;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * Borrowed from Mezr (v0.6.1):\n   * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @returns {Boolean}\n   */\n  function isTransformed(element) {\n\n    var transform = getStyle(element, 'transform');\n    var display = getStyle(element, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Calculate how many percent the intersection area of two rectangles is from\n   * the maximum potential intersection area between the rectangles.\n   *\n   * @private\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   *   - A number between 0-100.\n   */\n  function getRectOverlapScore(a, b) {\n\n    // Return 0 immediately if the rectangles do not overlap.\n    if (!muuriLayout.doRectsOverlap(a, b)) {\n      return 0;\n    }\n\n    // Calculate intersection area's width, height, max height and max width.\n    var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n    var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n    var maxWidth = Math.min(a.width, b.width);\n    var maxHeight = Math.min(a.height, b.height);\n\n    return (width * height) / (maxWidth * maxHeight) * 100;\n\n  }\n\n  /**\n   * Helpers - Item sort utilities\n   * *****************************\n   */\n\n  /**\n   * Helper for the sort method to generate mapped version of the items array\n   * than contains reference to the item indices.\n   *\n   * @private\n   * @param {Item[]} items\n   * @returns {Object}\n   */\n  function getItemIndexMap(items) {\n\n    var ret = {};\n    var i;\n\n    for (i = 0; i < items.length; i++) {\n      ret[items[i]._id] = i;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Helper for the sort method to compare the indices of the items to enforce\n   * stable sort.\n   *\n   * @private\n   * @param {Item} itemA\n   * @param {Item} itemB\n   * @param {Boolean} isDescending\n   * @param {Object} indexMap\n   * @returns {Number}\n   */\n  function compareItemIndices(itemA, itemB, isDescending, indexMap) {\n\n    var indexA = indexMap[itemA._id];\n    var indexB = indexMap[itemB._id];\n    return isDescending ? indexB - indexA : indexA - indexB;\n\n  }\n\n  /**\n   * Helper for the sort method to compare the items based on the provided\n   * attributes.\n   *\n   * @private\n   * @param {Item} itemA\n   * @param {Item} itemB\n   * @param {Boolean} isDescending\n   * @param {Object} criterias\n   * @returns {Number}\n   */\n  function compareItems(itemA, itemB, isDescending, criterias) {\n\n    var ret = 0;\n    var criteriaName;\n    var criteriaOrder;\n    var valA;\n    var valB;\n    var i;\n\n    // Loop through the list of sort criterias.\n    for (i = 0; i < criterias.length; i++) {\n\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = criterias[i][0];\n      criteriaOrder = criterias[i][1];\n\n      // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n      valA = (itemA._sortData ? itemA : itemA._refreshSortData())._sortData[criteriaName];\n      valB = (itemB._sortData ? itemB : itemB._refreshSortData())._sortData[criteriaName];\n\n      // Sort the items in descending order if defined so explicitly.\n      if (criteriaOrder === 'desc' || (!criteriaOrder && isDescending)) {\n        ret = valB < valA ? -1 : valB > valA ? 1 : 0;\n      }\n\n      // Otherwise sort items in ascending order.\n      else {\n        ret = valA < valB ? -1 : valA > valB ? 1 : 0;\n      }\n\n      // If we have -1 or 1 as the return value, let's return it immediately.\n      if (ret !== 0) {\n        return ret;\n      }\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Reorder an array of items based on another array of items.\n   *\n   * @private\n   * @param {Item[]} items\n   * @param {Item[]} refItems\n   * @returns {Item[]}\n   */\n  function sortItemsByReference(items, refItems) {\n\n    var newItems = [];\n    var currentItems = items.concat();\n    var item;\n    var currentIndex;\n    var i;\n\n    for (i = 0; i < refItems.length; i++) {\n      item = refItems[i];\n      currentIndex = currentItems.indexOf(item);\n      if (currentIndex > -1) {\n        newItems.push(item);\n        currentItems.splice(currentIndex, 1);\n      }\n    }\n\n    items.splice.apply(items, [0, items.length].concat(newItems).concat(currentItems));\n\n    return items;\n\n  }\n\n  /**\n   * Check if a point (coordinate) is within a rectangle.\n   *\n   * @private\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Rectangle} rect\n   * @return {Boolean}\n   */\n  function isPointWithinRect(x, y, rect) {\n\n    return rect.width\n      && rect.height\n      && x >= rect.left\n      && x < (rect.left + rect.width)\n      && y >= rect.top\n      && y < (rect.top + rect.height);\n\n  }\n\n  /**\n   * Helpers - Muuri\n   * ***************\n   */\n\n  /**\n   * Show or hide Grid instance's items.\n   *\n   * @private\n   * @param {Grid} inst\n   * @param {String} method\n   *   - \"show\" or \"hide\".\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {(ShowCallback|HideCallback)} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  function gridShowHideHandler(inst, method, items, options) {\n\n    var targetItems = inst.getItems(items);\n    var opts = options || {};\n    var isInstant = opts.instant === true;\n    var callback = opts.onFinish;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var counter = targetItems.length;\n    var isShow = method === 'show';\n    var startEvent = isShow ? evShowStart : evHideStart;\n    var endEvent = isShow ? evShowEnd : evHideEnd;\n    var needsLayout = false;\n    var completedItems = [];\n    var hiddenItems = [];\n    var item;\n    var i;\n\n    // If there are no items call the callback, but don't emit any events.\n    if (!counter) {\n      if (typeof callback === typeFunction) {\n        callback(targetItems);\n      }\n    }\n\n    // Otherwise if we have some items let's dig in.\n    else {\n\n      // Emit showStart/hideStart event.\n      inst._emit(startEvent, targetItems.concat());\n\n      // Show/hide items.\n      for (i = 0; i < targetItems.length; i++) {\n\n        item = targetItems[i];\n\n        // If inactive item is shown or active item is hidden we need to do\n        // layout.\n        if ((isShow && !item._isActive) || (!isShow && item._isActive)) {\n          needsLayout = true;\n        }\n\n        // If inactive item is shown we also need to do some special hackery to\n        // make the item not animate it's next positioning (layout).\n        if (isShow && !item._isActive) {\n          item._skipNextLayoutAnimation = true;\n        }\n\n        // If the a hidden item is being shown we need to refresh the item's\n        // dimensions.\n        isShow && item._isHidden && hiddenItems.push(item);\n\n        // Show/hide the item.\n        item['_' + method](isInstant, function (interrupted, item) {\n\n          // If the current item's animation was not interrupted add it to the\n          // completedItems array.\n          if (!interrupted) {\n            completedItems.push(item);\n          }\n\n          // If all items have finished their animations call the callback\n          // and emit showEnd/hideEnd event.\n          if (--counter < 1) {\n            if (typeof callback === typeFunction) {\n              callback(completedItems.concat());\n            }\n            inst._emit(endEvent, completedItems.concat());\n          }\n\n        });\n\n      }\n\n      // Refresh hidden items.\n      hiddenItems.length && inst.refreshItems(hiddenItems);\n\n      // Layout if needed.\n      if (needsLayout && layout) {\n        inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n      }\n\n    }\n\n    return inst;\n\n  }\n\n  /**\n   * Returns an object which contains start and stop methods for item's\n   * show/hide process.\n   *\n   * @param {String} type\n   * @param {Object} settings\n   * @returns {Object}\n   */\n  function getItemVisibilityHandler(type, settings) {\n\n    var isShow = type === 'show';\n    var duration = parseInt(isShow ? settings.showDuration : settings.hideDuration) || 0;\n    var easing = (isShow ? settings.showEasing : settings.hideEasing) || 'ease';\n    var styles = isShow ? settings.visibleStyles : settings.hiddenStyles;\n    var isEnabled = duration > 0;\n    var currentStyles;\n\n    styles = isPlainObject(styles) ? styles : null;\n\n    return {\n      start: function (item, instant, onFinish) {\n        if (!styles) {\n          onFinish && onFinish();\n        }\n        else {\n          rafLoop.cancel(rafQueueVisibility, item._id);\n          if (!isEnabled || instant) {\n            if (item._animateChild.isAnimating()) {\n              item._animateChild.stop(styles);\n            }\n            else {\n              setStyles(item._child, styles);\n            }\n            onFinish && onFinish();\n          }\n          else {\n            rafLoop.add(rafQueueVisibility, item._id, function () {\n              currentStyles = getCurrentStyles(item._child, styles);\n            }, function () {\n              item._animateChild.start(currentStyles, styles, {\n                duration: duration,\n                easing: easing,\n                onFinish: onFinish\n              });\n            });\n          }\n        }\n      },\n      stop: function (item, targetStyles) {\n        rafLoop.cancel(rafQueueVisibility, item._id);\n        item._animateChild.stop(targetStyles);\n      }\n    };\n\n  }\n\n  /**\n   * Get target grid for the default drag sort predicate.\n   *\n   * @private\n   * @param {Item} item\n   * @param {Grid} rootGrid\n   * @param {Rectangle} itemRect\n   * @param {Number} threshold\n   * @returns {?Grid}\n   */\n  function getTargetGrid(item, rootGrid, itemRect, threshold) {\n\n    var ret = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var grids = dragSort === true ? [rootGrid] : dragSort.call(rootGrid, item);\n    var bestScore = -1;\n    var gridScore;\n    var grid;\n    var i;\n\n    // Return immediately if there are no grids.\n    if (!Array.isArray(grids)) {\n      return ret;\n    }\n\n    // Loop through the grids and get the best match.\n    for (i = 0; i < grids.length; i++) {\n\n      grid = grids[i];\n\n      // Filter out all destroyed grids.\n      if (grid._isDestroyed) {\n        continue;\n      }\n\n      // We need to update the grid's offset since it may have changed during\n      // scrolling. This could be left as problem for the userland, but it's\n      // much nicer this way. One less hack for the user to worry about =)\n      grid._refreshDimensions();\n\n      // Check how much dragged element overlaps the container element.\n      gridScore = getRectOverlapScore(itemRect, {\n        width: grid._width,\n        height: grid._height,\n        left: grid._left,\n        top: grid._top\n      });\n\n      // Check if this grid is the best match so far.\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        ret = grid;\n      }\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Process item's callback queue.\n   *\n   * @private\n   * @param {Function[]} queue\n   * @param {Boolean} interrupted\n   * @param {Item} instance\n   */\n  function processQueue(queue, interrupted, instance) {\n\n    var callbacks = queue.splice(0, queue.length);\n    var i;\n\n    for (i = 0; i < callbacks.length; i++) {\n      callbacks[i](interrupted, instance);\n    }\n\n  }\n\n  /**\n   * Check if item is in specific state.\n   *\n   * @private\n   * @param {Item} item\n   * @param {GridItemState} state\n   *  - Accepted values are: \"active\", \"inactive\", \"visible\", \"hidden\",\n   *    \"showing\", \"hiding\", \"positioning\", \"dragging\", \"releasing\" and\n   *    \"migrating\".\n   * @returns {Boolean}\n   */\n  function isItemInState(item, state) {\n\n    var methodName;\n\n    if (state === 'inactive') {\n      return !item.isActive();\n    }\n\n    if (state === 'hidden') {\n      return !item.isVisible();\n    }\n\n    methodName = 'is' + state.charAt(0).toUpperCase() + state.slice(1);\n\n    return typeof item[methodName] === typeFunction ? item[methodName]() : false;\n\n  }\n\n  /**\n   * Prevent default.\n   *\n   * @private\n   * @param {Object} e\n   */\n  function preventDefault(e) {\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n  }\n\n  /**\n   * Merge default settings with user settings. The returned object is a new\n   * object with merged values. The merging is a deep merge meaning that all\n   * objects and arrays within the provided settings objects will be also merged\n   * so that modifying the values of the settings object will have no effect on\n   * the returned object.\n   *\n   * @private\n   * @param {Object} defaultSettings\n   * @param {Object} [userSettings]\n   * @returns {Object} Returns a new object.\n   */\n  function mergeSettings(defaultSettings, userSettings) {\n\n    // Create a fresh copy of default settings.\n    var ret = mergeObjects({}, defaultSettings);\n\n    // Merge user settings to default settings.\n    ret = userSettings ? mergeObjects(ret, userSettings) : ret;\n\n    // Handle visible/hidden styles manually so that the whole object is\n    // overriden instead of the props.\n    ret.visibleStyles = (userSettings || {}).visibleStyles || (defaultSettings || {}).visibleStyles;\n    ret.hiddenStyles = (userSettings || {}).hiddenStyles || (defaultSettings || {}).hiddenStyles;\n\n    return ret;\n\n  }\n\n  /**\n   * Resolver for default drag start predicate function.\n   *\n   * @private\n   * @param {Item} item\n   * @param {Object} event\n   * @returns {Boolean}\n   */\n  function dragStartPredicateResolve(item, event) {\n\n    var predicate = item._drag._startPredicateData;\n    var pointer = event.changedPointers[0];\n    var pageX = pointer && pointer.pageX || 0;\n    var pageY = pointer && pointer.pageY || 0;\n    var handleRect;\n\n    // If the moved distance is smaller than the threshold distance or there is\n    // some delay left, ignore this predicate cycle.\n    if (event.distance < predicate.distance || predicate.delay) {\n      return;\n    }\n\n    // Get handle rect.\n    handleRect = predicate.handleElement.getBoundingClientRect();\n\n    // Reset predicate data.\n    dragStartPredicateReset(item);\n\n    // If the cursor is still within the handle let's start the drag.\n    return isPointWithinRect(pageX, pageY, {\n      width: handleRect.width,\n      height: handleRect.height,\n      left: handleRect.left + (global.pageXOffset || 0),\n      top: handleRect.top + (global.pageYOffset || 0)\n    });\n\n  }\n\n  /**\n   * Reset for default drag start predicate function.\n   *\n   * @private\n   * @param {Item} item\n   */\n  function dragStartPredicateReset(item) {\n\n    var predicate = item._drag._startPredicateData;\n\n    if (predicate) {\n      if (predicate.delayTimer) {\n        predicate.delayTimer = global.clearTimeout(predicate.delayTimer);\n      }\n      item._drag._startPredicateData = null;\n    }\n\n  }\n\n  /**\n   * Default layout algorithm\n   * ************************\n   */\n\n  /*!\n    * muuriLayout v0.5.4\n    * Copyright (c) 2016 Niklas Rm <inramo@gmail.com>\n    * Released under the MIT license\n    */\n\n  /**\n   * The default Muuri layout algorithm. Based on MAXRECTS approach as described\n   * by Jukka Jylnki in his survey: \"A Thousand Ways to Pack the Bin - A\n   * Practical Approach to Two-Dimensional Rectangle Bin Packing.\".\n   *\n   * This algorithm is intentionally separated from the rest of the codebase,\n   * because it is it's own library with a different copyright than the rest of\n   * the software. It's also MIT licensed so no worries there. This is intended\n   * to be used as Muuri's default layout algorithm and goes hand in hand with\n   * Muuri's core development.\n   *\n   * @private\n   * @param {Item[]} items\n   * @param {Number} width\n   * @param {Number} height\n   * @param {Object} options\n   * @param {Boolean} [options.fillGaps=false]\n   * @param {Boolean} [options.horizontal=false]\n   * @param {Boolean} [options.alignRight=false]\n   * @param {Boolean} [options.alignBottom=false]\n   * @returns {LayoutData}\n   */\n  function muuriLayout(items, width, height, options) {\n\n    var fillGaps = !!options.fillGaps;\n    var isHorizontal = !!options.horizontal;\n    var alignRight = !!options.alignRight;\n    var alignBottom = !!options.alignBottom;\n    var rounding = !!options.rounding;\n    var layout = {\n      slots: {},\n      width: isHorizontal ? 0 : (rounding ? Math.round(width) : width),\n      height: !isHorizontal ? 0 : (rounding ? Math.round(height) : height),\n      setWidth: isHorizontal,\n      setHeight: !isHorizontal\n    };\n    var freeSlots = [];\n    var slotIds;\n    var slotData;\n    var slot;\n    var item;\n    var itemWidth;\n    var itemHeight;\n    var i;\n\n    // No need to go further if items do not exist.\n    if (!items.length) {\n      return layout;\n    }\n\n    // Find slots for items.\n    for (i = 0; i < items.length; i++) {\n      item = items[i];\n      itemWidth = item._width + item._margin.left + item._margin.right;\n      itemHeight = item._height + item._margin.top + item._margin.bottom;\n      if (rounding) {\n        itemWidth = Math.round(itemWidth);\n        itemHeight = Math.round(itemHeight);\n      }\n      slotData = muuriLayout.getSlot(layout, freeSlots, itemWidth, itemHeight, !isHorizontal, fillGaps);\n      slot = slotData[0];\n      freeSlots = slotData[1];\n      if (isHorizontal) {\n        layout.width = Math.max(layout.width, slot.left + slot.width);\n      }\n      else {\n        layout.height = Math.max(layout.height, slot.top + slot.height);\n      }\n      layout.slots[item._id] = slot;\n    }\n\n    // If the alignment is set to right or bottom, we need to adjust the\n    // results.\n    if (alignRight || alignBottom) {\n      slotIds = Object.keys(layout.slots);\n      for (i = 0; i < slotIds.length; i++) {\n        slot = layout.slots[slotIds[i]];\n        if (alignRight) {\n          slot.left = layout.width - (slot.left + slot.width);\n        }\n        if (alignBottom) {\n          slot.top = layout.height - (slot.top + slot.height);\n        }\n      }\n    }\n\n    return layout;\n\n  }\n\n  /**\n   * Calculate position for the layout item. Returns the left and top position\n   * of the item in pixels.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Layout} layout\n   * @param {Array} slots\n   * @param {Number} itemWidth\n   * @param {Number} itemHeight\n   * @param {Boolean} vertical\n   * @param {Boolean} fillGaps\n   * @returns {Array}\n   */\n  muuriLayout.getSlot = function (layout, slots, itemWidth, itemHeight, vertical, fillGaps) {\n\n    var leeway = 0.001;\n    var newSlots = [];\n    var item = {\n      left: null,\n      top: null,\n      width: itemWidth,\n      height: itemHeight\n    };\n    var slot;\n    var potentialSlots;\n    var ignoreCurrentSlots;\n    var i;\n    var ii;\n\n    // Try to find a slot for the item.\n    for (i = 0; i < slots.length; i++) {\n      slot = slots[i];\n      if (item.width <= (slot.width + leeway) && item.height <= (slot.height + leeway)) {\n        item.left = slot.left;\n        item.top = slot.top;\n        break;\n      }\n    }\n\n    // If no slot was found for the item.\n    if (item.left === null) {\n\n      // Position the item in to the bottom left (vertical mode) or top right\n      // (horizontal mode) of the grid.\n      item.left = vertical ? 0 : layout.width;\n      item.top = vertical ? layout.height : 0;\n\n      // If gaps don't needs filling do not add any current slots to the new\n      // slots array.\n      if (!fillGaps) {\n        ignoreCurrentSlots = true;\n      }\n\n    }\n\n    // In vertical mode, if the item's bottom overlaps the grid's bottom.\n    if (vertical && (item.top + item.height) > layout.height) {\n\n      // If item is not aligned to the left edge, create a new slot.\n      if (item.left > 0) {\n        newSlots.push({\n          left: 0,\n          top: layout.height,\n          width: item.left,\n          height: Infinity\n        });\n      }\n\n      // If item is not aligned to the right edge, create a new slot.\n      if ((item.left + item.width) < layout.width) {\n        newSlots.push({\n          left: item.left + item.width,\n          top: layout.height,\n          width: layout.width - item.left - item.width,\n          height: Infinity\n        });\n      }\n\n      // Update grid height.\n      layout.height = item.top + item.height;\n\n    }\n\n    // In horizontal mode, if the item's right overlaps the grid's right edge.\n    if (!vertical && (item.left + item.width) > layout.width) {\n\n      // If item is not aligned to the top, create a new slot.\n      if (item.top > 0) {\n        newSlots.push({\n          left: layout.width,\n          top: 0,\n          width: Infinity,\n          height: item.top\n        });\n      }\n\n      // If item is not aligned to the bottom, create a new slot.\n      if ((item.top + item.height) < layout.height) {\n        newSlots.push({\n          left: layout.width,\n          top: item.top + item.height,\n          width: Infinity,\n          height: layout.height - item.top - item.height\n        });\n      }\n\n      // Update grid width.\n      layout.width = item.left + item.width;\n\n    }\n\n    // Clean up the current slots making sure there are no old slots that\n    // overlap with the item. If an old slot overlaps with the item, split it\n    // into smaller slots if necessary.\n    for (i = fillGaps ? 0 : ignoreCurrentSlots ? slots.length : i; i < slots.length; i++) {\n      potentialSlots = muuriLayout.splitRect(slots[i], item);\n      for (ii = 0; ii < potentialSlots.length; ii++) {\n        slot = potentialSlots[ii];\n        // Let's make sure here that we have a big enough slot\n        // (width/height > 0.49px) and also let's make sure that the slot is\n        // within the boundaries of the grid.\n        if (slot.width > 0.49 && slot.height > 0.49 && ((vertical && slot.top < layout.height) || (!vertical && slot.left < layout.width))) {\n          newSlots.push(slot);\n        }\n      }\n    }\n\n    // Sanitize new slots.\n    if (newSlots.length) {\n      newSlots = muuriLayout.purgeRects(newSlots).sort(vertical ? muuriLayout.sortRectsTopLeft : muuriLayout.sortRectsLeftTop);\n    }\n\n    // Return the item and updated slots data.\n    return [item, newSlots];\n\n  };\n\n  /**\n   * Punch a hole into a rectangle and split the remaining area into smaller\n   * rectangles (4 at max).\n   *\n   * @private\n   * @param {Rectangle} rect\n   * @param {Rectangle} hole\n   * returns {Rectangle[]}\n   */\n  muuriLayout.splitRect = function (rect, hole) {\n\n    var ret = [];\n\n    // If the rect does not overlap with the hole add rect to the return data as\n    // is.\n    if (!muuriLayout.doRectsOverlap(rect, hole)) {\n      return [{\n        left: rect.left,\n        top: rect.top,\n        width: rect.width,\n        height: rect.height\n      }];\n    }\n\n    // Left split.\n    if (rect.left < hole.left) {\n      ret.push({\n        left: rect.left,\n        top: rect.top,\n        width: hole.left - rect.left,\n        height: rect.height\n      });\n    }\n\n    // Right split.\n    if ((rect.left + rect.width) > (hole.left + hole.width)) {\n      ret.push({\n        left: hole.left + hole.width,\n        top: rect.top,\n        width: (rect.left + rect.width) - (hole.left + hole.width),\n        height: rect.height\n      });\n    }\n\n    // Top split.\n    if (rect.top < hole.top) {\n      ret.push({\n        left: rect.left,\n        top: rect.top,\n        width: rect.width,\n        height: hole.top - rect.top\n      });\n    }\n\n    // Bottom split.\n    if ((rect.top + rect.height) > (hole.top + hole.height)) {\n      ret.push({\n        left: rect.left,\n        top: hole.top + hole.height,\n        width: rect.width,\n        height: (rect.top + rect.height) - (hole.top + hole.height)\n      });\n    }\n\n    return ret;\n\n  };\n\n  /**\n   * Check if two rectangles overlap.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Boolean}\n   */\n  muuriLayout.doRectsOverlap = function (a, b) {\n\n    return !((a.left + a.width) <= b.left || (b.left + b.width) <= a.left || (a.top + a.height) <= b.top || (b.top + b.height) <= a.top);\n\n  };\n\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Boolean}\n   */\n  muuriLayout.isRectWithinRect = function (a, b) {\n\n    return a.left >= b.left && a.top >= b.top && (a.left + a.width) <= (b.left + b.width) && (a.top + a.height) <= (b.top + b.height);\n\n  };\n\n  /**\n   * Loops through an array of rectangles and removes all that are fully within\n   * another rectangle in the array.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle[]} rects\n   * @returns {Rectangle[]}\n   */\n  muuriLayout.purgeRects = function (rects) {\n\n    var i = rects.length;\n    var ii;\n    var rectA;\n    var rectB;\n\n    while (i--) {\n      rectA = rects[i];\n      ii = rects.length;\n      while (ii--) {\n        rectB = rects[ii];\n        if (i !== ii && muuriLayout.isRectWithinRect(rectA, rectB)) {\n          rects.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    return rects;\n\n  };\n\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   */\n  muuriLayout.sortRectsTopLeft = function (a, b) {\n\n    return a.top - b.top || a.left - b.left;\n\n  };\n\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   */\n  muuriLayout.sortRectsLeftTop = function (a, b) {\n\n    return a.left - b.left || a.top - b.top;\n\n  };\n\n  /**\n   * Type definitions\n   * ****************\n   */\n\n  /* eslint-disable */\n  /**\n   * The values by which multiple grid items can be queried. An html element or\n   * an array of HTML elements. Item or an array of items. Node list, live or\n   * static. Number (index) or a list of numbers (indices).\n   *\n   * @typedef {(HTMLElement|HTMLElement[]|Item|Item[]|NodeList|Number|Number[])} GridMultiItemQuery\n   */\n  /* eslint-enable */\n\n  /**\n   * The values by which a single grid item can be queried. An html element, an\n   * item instance or a number (index).\n   *\n   * @typedef {(HTMLElement|Item|Number)} GridSingleItemQuery\n   */\n\n  /**\n   * The grid item's state, a string. Accepted values are: \"active\", \"inactive\",\n   * \"visible\", \"hidden\", \"showing\", \"hiding\", \"positioning\", \"dragging\",\n   * \"releasing\" and \"migrating\".\n   *\n   * @typedef {String} GridItemState\n   */\n\n  /**\n   * The data that is required to orchestrate a sort action during drag.\n   *\n   * @typedef {Object} DragSortCommand\n   * @param {String} action\n   *   - \"move\" or \"swap\".\n   * @param {Number} index\n   *   - target index.\n   * @param {?Grid} [grid=null]\n   *   - target grid.\n   */\n\n  /**\n   * A rectangle is an object with width, height and offset (left and top) data.\n   *\n   * @typedef {Object} Rectangle\n   * @property {Number} width\n   * @property {Number} height\n   * @property {Number} left\n   * @property {Number} top\n   */\n\n  /**\n   * Layout data for the layout instance.\n   *\n   * @typedef {Object} LayoutData\n   * @property {Object} slots\n   * @property {Number} width\n   * @property {Number} height\n   * @property {Boolean} setWidth\n   * @property {Boolean} setHeight\n   */\n\n  /**\n   * @callback LayoutCallback\n   * @param {Boolean} isAborted\n   *   - Was the layout procedure aborted?\n   * @param {Item[]} items\n   *   - The items that were attempted to be positioned.\n   */\n\n  /**\n   * @callback ShowCallback\n   * @param {Item[]} items\n   *   - The items that were successfully shown without interruptions.\n   */\n\n  /**\n   * @callback HideCallback\n   * @param {Item[]} items\n   *   - The items that were successfully hidden without interruptions.\n   */\n\n  /**\n   * @callback FilterCallback\n   * @param {Item[]} shownItems\n   *   - The items that were shown.\n   * @param {Item[]} hiddenItems\n   *   - The items that were hidden.\n   */\n\n  /**\n   * Init\n   */\n\n  return Grid;\n\n}));\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","/* @flow */\n\n\nexport const IdManager = new class {\n    TPL_ANSWER_CONTAINER: string;\n    TPL_CANDIDATES_CONTAINER: string;\n\n    pid: string;\n    _initialized: boolean;\n\n    constructor() {\n        this._initialized = false;\n\n        this.TPL_ANSWER_CONTAINER = '$pid-answer'\n        this.TPL_CANDIDATES_CONTAINER = '$pid-candidates';\n    }\n\n    // Lazy initialization\n    init(pid: string) {\n        this.pid = pid;\n        this._initialized = true;\n    }\n\n    stringify(template: string, itemid: string|null = null) {\n        if(!this._initialized) throw 'Uninitialized IdManager';\n\n        if(itemid==null) return template.replace('$pid', this.pid)\n\t    else return template.replace('$pid', this.pid).replace('$item', itemid)\n    }\n}\n","/* @flow */\nimport Muuri from 'muuri';\nimport {IdManager} from './IdManager';\n\n\nexport default class GridSystem {\n\tcolumnGrids : Array<Muuri>;\n    boardGrid : Muuri;\n    \n    hiddenInputs : Array<HTMLElement>;\n\n\tconstructor(answerContainer: HTMLElement, candidatesContainer: HTMLElement, hiddenInputs: Array<HTMLElement>) {\n        this.hiddenInputs = hiddenInputs;\n\n\t\tthis.columnGrids = []\n\n        this.generate_muuri(answerContainer, 'ANSWERS')\n        this.generate_muuri(candidatesContainer, 'CANDIDATES')\n\n\t\tthis.boardGrid = new Muuri('.permutation', {\n\t\t\tlayoutDuration: 400,\n\t\t\tlayoutEasing: 'ease',\n\t\t\tdragEnabled: true,\n\t\t\tdragSortInterval: 0,\n\t\t\tdragStartPredicate: {\n\t\t\t\thandle: '.permutation-column-header'\n\t\t\t},\n\t\t\tdragReleaseDuration: 400,\n\t\t\tdragReleaseEasing: 'ease'\n\t\t});\n\t}\n\n\tgenerate_muuri(container: HTMLElement, name: string) {\n\t\tvar that = this;\n\n\t\tvar grid = new Muuri(container, {\n\t\t\titems: '.permutation-item',\n\t\t\tlayoutDuration: 400,\n\t\t\tlayoutEasing: 'ease',\n\t\t\tdragEnabled: true,\n\t\t\tdragSort: function () {\n\t\t\t\treturn that.columnGrids;\n\t\t\t},\n\t\t\tdragSortInterval: 0,\n\t\t\tdragContainer: document.body, // TODO: can we drag items in the whole body?\n\t\t\tdragReleaseDuration: 400,\n\t\t\tdragReleaseEasing: 'ease'\n\t\t})\n\t\t.on('dragStart', function (item) {\n\t\t\t// Let's set fixed widht/height to the dragged item\n\t\t\t// so that it does not stretch unwillingly when\n\t\t\t// it's appended to the document body for the\n\t\t\t// duration of the drag.\n\t\t\titem.getElement().style.width = item.getWidth() + 'px';\n\t\t\titem.getElement().style.height = item.getHeight() + 'px';\n\t\t\tconsole.log('Pressed element at' + name);\n\t\t})\n\t\t.on('dragReleaseEnd', function (item) {\n\t\t\t// Let's remove the fixed width/height from the\n\t\t\t// dragged item now that it is back in a grid\n\t\t\t// column and can freely adjust to it's\n\t\t\t// surroundings.\n\t\t\titem.getElement().style.width = '';\n\t\t\titem.getElement().style.height = '';\n\t\t\t// Just in case, let's refresh the dimensions of all items\n\t\t\t// in case dragging the item caused some other items to\n\t\t\t// be different size.\n\t\t\tthat.columnGrids.forEach(function (grid) {\n\t\t\t\tgrid.refreshItems();\n\t\t\t});\n\t\t\tconsole.log('Released element at' + name);\n\t\t})\n\t\t.on('layoutStart', function () {\n\t\t\t// Let's keep the board grid up to date with the\n\t\t\t// dimensions changes of column grids.\n\t\t\tthat.boardGrid.refreshItems().layout();\n\t\t});\n\n\t\tthat.columnGrids.push(grid);\n\t}\n}","/* @flow */\nimport GridSystem from './GridSystem';\nimport {IdManager} from './IdManager';\n\n\nconst itemFactory = (elemId: string, text: string) => {\n\tconst item = document.createElement('div')\n\titem.setAttribute('class', 'permutation-item')\n\t\n\tconst itemContent = document.createElement('div')\n\titemContent.setAttribute('id', elemId)\n\titemContent.setAttribute('class', 'permutation-item-content')\n\titemContent.innerHTML = text;\n\titem.appendChild(itemContent)\n\n\treturn item\n}\n\n\nexport function generate_ui(pid: string) {\n\tIdManager.init(pid);\n\n\tvar nullAnswersContainer: HTMLElement|null = document.getElementById(IdManager.stringify(IdManager.TPL_ANSWER_CONTAINER))\n\tvar nullCandidatesContainer: HTMLElement|null = document.getElementById(IdManager.stringify(IdManager.TPL_CANDIDATES_CONTAINER))\n\n\tif(nullAnswersContainer==null || nullCandidatesContainer==null) return;\n\n\tconst answersContainer: HTMLElement = nullAnswersContainer;\n\tconst candidatesContainer: HTMLElement = nullCandidatesContainer;\n\n\tnew GridSystem(answersContainer, candidatesContainer, [])\n}\n\n\n// generate_permutation_list([Array(110).join(' C-C C+C ') + ';','D','A','B'], '.board-column-content');\n","module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n"],"sourceRoot":""}