var PermutationTaskUI =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n})(window, document, 'Hammer');\n\n\n//# sourceURL=webpack://PermutationTaskUI/./node_modules/hammerjs/hammer.js?");

/***/ }),

/***/ "./node_modules/muuri/muuri.js":
/*!*************************************!*\
  !*** ./node_modules/muuri/muuri.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Muuri v0.5.4\n * https://github.com/haltu/muuri\n * Copyright (c) 2015, Haltu Oy\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function (global, factory) {\n\n  var namespace = 'Muuri';\n  var Hammer;\n\n  if (typeof module === 'object' && module.exports) {\n    /* eslint-disable */\n    try { Hammer = __webpack_require__(/*! hammerjs */ \"./node_modules/hammerjs/hammer.js\"); } catch (e) {}\n    /* eslint-enable */\n    module.exports = factory(namespace, Hammer);\n  }\n  else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! hammerjs */ \"./node_modules/hammerjs/hammer.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Hammer) {\n      return factory(namespace, Hammer);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  else {}\n\n}(typeof window !== 'undefined' ? window : this, function (namespace, Hammer, undefined) {\n\n  'use strict';\n\n  // Get references to all the stuff we are using from the global scope.\n  var global = window;\n  var Object = global.Object;\n  var Array = global.Array;\n  var Math = global.Math;\n  var Error = global.Error;\n  var Element = global.Element;\n  var doc = global.document;\n  var docElem = doc.documentElement;\n  var body = doc.body;\n\n  // Types.\n  var typeFunction = 'function';\n  var typeString = 'string';\n  var typeNumber = 'number';\n\n  // Raf loop that can be used to organize DOM write and read operations\n  // optimally in the next animation frame.\n  var rafLoop = createRafLoop();\n\n  // Raf loop queue names.\n  var rafQueueLayout = 'layout';\n  var rafQueueVisibility = 'visibility';\n  var rafQueueMove = 'move';\n  var rafQueueScroll = 'scroll';\n\n  // Drag start predicate states.\n  var startPredicateInactive = 0;\n  var startPredicatePending = 1;\n  var startPredicateResolved = 2;\n  var startPredicateRejected = 3;\n\n  // Keep track of Grid instances.\n  var gridInstances = {};\n\n  // Keep track of Item instances.\n  var itemInstances = {};\n\n  // No operation function.\n  var noop = function () {};\n\n  // Unique id which is used for Grid instances and Item instances.\n  // Should be incremented every time when used.\n  var uuid = 0;\n\n  // Get the supported element.matches().\n  var elementMatches = getSupportedElementMatches();\n\n  // Get the supported transform style property.\n  var transform = getSupportedStyle('transform');\n\n  // Test if transformed elements leak fixed elements.\n  var transformLeaksFixed = body ? doesTransformLeakFixed() : null;\n\n  // Event names.\n  var evSynchronize = 'synchronize';\n  var evLayoutStart = 'layoutStart';\n  var evLayoutEnd = 'layoutEnd';\n  var evAdd = 'add';\n  var evRemove = 'remove';\n  var evShowStart = 'showStart';\n  var evShowEnd = 'showEnd';\n  var evHideStart = 'hideStart';\n  var evHideEnd = 'hideEnd';\n  var evFilter = 'filter';\n  var evSort = 'sort';\n  var evMove = 'move';\n  var evSend = 'send';\n  var evBeforeSend = 'beforeSend';\n  var evReceive = 'receive';\n  var evBeforeReceive = 'beforeReceive';\n  var evDragInit = 'dragInit';\n  var evDragStart = 'dragStart';\n  var evDragMove = 'dragMove';\n  var evDragScroll = 'dragScroll';\n  var evDragEnd = 'dragEnd';\n  var evDragReleaseStart = 'dragReleaseStart';\n  var evDragReleaseEnd = 'dragReleaseEnd';\n  var evDestroy = 'destroy';\n\n  /**\n   * Grid\n   * ****\n   */\n\n  /**\n   * Creates a new Grid instance.\n   *\n   * @public\n   * @class\n   * @param {(HTMLElement|String)} element\n   * @param {Object} [options]\n   * @param {(?HTMLElement[]|NodeList|String)} [options.items]\n   * @param {Number} [options.showDuration=300]\n   * @param {String} [options.showEasing=\"ease\"]\n   * @param {Object} [options.visibleStyles]\n   * @param {Number} [options.hideDuration=300]\n   * @param {String} [options.hideEasing=\"ease\"]\n   * @param {Object} [options.hiddenStyles]\n   * @param {(Function|Object)} [options.layout]\n   * @param {Boolean} [options.layout.fillGaps=false]\n   * @param {Boolean} [options.layout.horizontal=false]\n   * @param {Boolean} [options.layout.alignRight=false]\n   * @param {Boolean} [options.layout.alignBottom=false]\n   * @param {Boolean} [options.layout.rounding=true]\n   * @param {(Boolean|Number)} [options.layoutOnResize=100]\n   * @param {Boolean} [options.layoutOnInit=true]\n   * @param {Number} [options.layoutDuration=300]\n   * @param {String} [options.layoutEasing=\"ease\"]\n   * @param {?Object} [options.sortData=null]\n   * @param {Boolean} [options.dragEnabled=false]\n   * @param {?HtmlElement} [options.dragContainer=null]\n   * @param {?Function} [options.dragStartPredicate]\n   * @param {Number} [options.dragStartPredicate.distance=0]\n   * @param {Number} [options.dragStartPredicate.delay=0]\n   * @param {(Boolean|String)} [options.dragStartPredicate.handle=false]\n   * @param {?String} [options.dragAxis]\n   * @param {(Boolean|Function)} [options.dragSort=true]\n   * @param {Number} [options.dragSortInterval=100]\n   * @param {(Function|Object)} [options.dragSortPredicate]\n   * @param {Number} [options.dragSortPredicate.threshold=50]\n   * @param {String} [options.dragSortPredicate.action=\"move\"]\n   * @param {Number} [options.dragReleaseDuration=300]\n   * @param {String} [options.dragReleaseEasing=\"ease\"]\n   * @param {Object} [options.dragHammerSettings={touchAction: \"none\"}]\n   * @param {String} [options.containerClass=\"muuri\"]\n   * @param {String} [options.itemClass=\"muuri-item\"]\n   * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n   * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n   * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n   * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n   * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n   */\n  function Grid(element, options) {\n\n    var inst = this;\n    var settings;\n    var items;\n    var layoutOnResize;\n\n    // Muuri can be loaded inside the head tag also, but in that case Muuri can\n    // not cache body element and run the initial DOM tests. So, if we detect\n    // that body element could not be fetched on init we do it here once and\n    // also run the DOM tests. If the Grid is instantiated before body is ready\n    // you are doing it wrong ;)\n    if (!body) {\n      body = document.body;\n      transformLeaksFixed = doesTransformLeakFixed();\n    }\n\n    // Allow passing element as selector string. Store element for instance.\n    element = inst._element = typeof element === typeString ? doc.querySelector(element) : element;\n\n    // Throw an error if the container element is not body element or does not\n    // exist within the body element.\n    if (!body.contains(element)) {\n      throw new Error('Container element must be an existing DOM element');\n    }\n\n    // Create instance settings by merging the options with default options.\n    settings = inst._settings = mergeSettings(Grid.defaultOptions, options);\n\n    // Sanitize dragSort setting.\n    if (typeof settings.dragSort !== typeFunction) {\n      settings.dragSort = !!settings.dragSort;\n    }\n\n    // Create instance id and store it to the grid instances collection.\n    gridInstances[inst._id = ++uuid] = inst;\n\n    // Destroyed flag.\n    inst._isDestroyed = false;\n\n    // Reference to the currently used Layout instance.\n    inst._layout = null;\n\n    // Create private Emitter instance.\n    inst._emitter = new Grid.Emitter();\n\n    // Setup grid's show/hide animation handler for items.\n    inst._itemShowHandler = getItemVisibilityHandler('show', settings);\n    inst._itemHideHandler = getItemVisibilityHandler('hide', settings);\n\n    // Add container element's class name.\n    addClass(element, settings.containerClass);\n\n    // Create initial items.\n    inst._items = [];\n    items = settings.items;\n    if (typeof items === typeString) {\n      nodeListToArray(inst._element.children).forEach(function (itemElement) {\n        if (items === '*' || elementMatches(itemElement, items)) {\n          inst._items.push(new Grid.Item(inst, itemElement));\n        }\n      });\n    }\n    else if (Array.isArray(items) || isNodeList(items)) {\n      inst._items = nodeListToArray(items).map(function (itemElement) {\n        return new Grid.Item(inst, itemElement);\n      });\n    }\n\n    // Sanitize layoutOnResize option and bind debounced resize handler if the\n    // layoutOnResize option a valid number.\n    layoutOnResize = settings.layoutOnResize;\n    layoutOnResize = layoutOnResize === true ? 0 : typeof layoutOnResize === typeNumber ? layoutOnResize : -1;\n    if (layoutOnResize >= 0) {\n      global.addEventListener('resize', inst._resizeHandler = debounce(function () {\n        inst.refreshItems().layout();\n      }, layoutOnResize));\n    }\n\n    // Layout on init if necessary.\n    if (settings.layoutOnInit) {\n      inst.layout(true);\n    }\n\n  }\n\n  /**\n   * Grid - Public properties\n   * ************************\n   */\n\n  /**\n   * @see Item\n   */\n  Grid.Item = Item;\n\n  /**\n   * @see ItemDrag\n   */\n  Grid.ItemDrag = ItemDrag;\n\n  /**\n   * @see ItemRelease\n   */\n  Grid.ItemRelease = ItemRelease;\n\n  /**\n   * @see ItemMigrate\n   */\n  Grid.ItemMigrate = ItemMigrate;\n\n  /**\n   * @see ItemAnimate\n   */\n  Grid.ItemAnimate = ItemAnimate;\n\n  /**\n   * @see Layout\n   */\n  Grid.Layout = Layout;\n\n  /**\n   * @see Emitter\n   */\n  Grid.Emitter = Emitter;\n\n  /**\n   * Default options for Grid instance.\n   *\n   * @public\n   * @memberof Grid\n   */\n  Grid.defaultOptions = {\n\n    // Item elements\n    items: '*',\n\n    // Default show animation\n    showDuration: 300,\n    showEasing: 'ease',\n\n    // Default hide animation\n    hideDuration: 300,\n    hideEasing: 'ease',\n\n    // Item's visible/hidden state styles\n    visibleStyles: {\n      opacity: '1',\n      transform: 'scale(1)'\n    },\n    hiddenStyles: {\n      opacity: '0',\n      transform: 'scale(0.5)'\n    },\n\n    // Layout\n    layout: {\n      fillGaps: false,\n      horizontal: false,\n      alignRight: false,\n      alignBottom: false,\n      rounding: true\n    },\n    layoutOnResize: 100,\n    layoutOnInit: true,\n    layoutDuration: 300,\n    layoutEasing: 'ease',\n\n    // Sorting\n    sortData: null,\n\n    // Drag & Drop\n    dragEnabled: false,\n    dragContainer: null,\n    dragStartPredicate: {\n      distance: 0,\n      delay: 0,\n      handle: false\n    },\n    dragAxis: null,\n    dragSort: true,\n    dragSortInterval: 100,\n    dragSortPredicate: {\n      threshold: 50,\n      action: 'move'\n    },\n    dragReleaseDuration: 300,\n    dragReleaseEasing: 'ease',\n    dragHammerSettings: {\n      touchAction: 'none'\n    },\n\n    // Classnames\n    containerClass: 'muuri',\n    itemClass: 'muuri-item',\n    itemVisibleClass: 'muuri-item-shown',\n    itemHiddenClass: 'muuri-item-hidden',\n    itemPositioningClass: 'muuri-item-positioning',\n    itemDraggingClass: 'muuri-item-dragging',\n    itemReleasingClass: 'muuri-item-releasing'\n\n  };\n\n  /**\n   * Grid - Private properties\n   * *************************\n   */\n\n  Grid._maxRafBatchSize = 100;\n\n  /**\n   * Grid - Public prototype methods\n   * *******************************\n   */\n\n  /**\n   * Bind an event listener.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.on = function (event, listener) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.on(event, listener);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Bind an event listener that is triggered only once.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.once = function (event, listener) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.once(event, listener);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Unbind an event listener.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.off = function (event, listener) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.off(event, listener);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Get the container element.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @returns {HTMLElement}\n   */\n  Grid.prototype.getElement = function () {\n\n    return this._element;\n\n  };\n\n  /**\n   * Get all items. Optionally you can provide specific targets (elements and\n   * indices) and filter the results based on the state of the items. Note that\n   * the returned array is not the same object used by the instance so modifying\n   * it will not affect instance's items. All items that are not found are\n   * omitted from the returned array.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} [targets]\n   * @param {GridItemState} [state]\n   * @returns {Item[]}\n   */\n  Grid.prototype.getItems = function (targets, state) {\n\n    var inst = this;\n\n    // Return an empty array immediately if the instance is destroyed.\n    if (inst._isDestroyed) {\n      return [];\n    }\n\n    var hasTargets = targets === 0 || (targets && typeof targets !== typeString);\n    var targetItems = !hasTargets ? null : isNodeList(targets) ? nodeListToArray(targets) : [].concat(targets);\n    var targetState = !hasTargets ? targets : state;\n    var ret = [];\n    var item;\n    var i;\n\n    // Sanitize target state.\n    targetState = typeof targetState === typeString ? targetState : null;\n\n    // If target state or target items are defined return filtered results.\n    if (targetState || targetItems) {\n      targetItems = targetItems || inst._items;\n      for (i = 0; i < targetItems.length; i++) {\n        item = hasTargets ? inst._getItem(targetItems[i]) : targetItems[i];\n        if (item && (!targetState || isItemInState(item, targetState))) {\n          ret.push(item);\n        }\n      }\n      return ret;\n    }\n\n    // Otherwise return all items.\n    else {\n      return ret.concat(inst._items);\n    }\n\n  };\n\n  /**\n   * Update the cached dimensions of the instance's items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} [items]\n   * @returns {Grid}\n   */\n  Grid.prototype.refreshItems = function (items) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var targetItems = inst.getItems(items || 'active');\n    var i;\n\n    for (i = 0; i < targetItems.length; i++) {\n      targetItems[i]._refreshDimensions();\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Update the sort data of the instance's items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} [items]\n   * @returns {Grid}\n   */\n  Grid.prototype.refreshSortData = function (items) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var targetItems = inst.getItems(items);\n    var i;\n\n    for (i = 0; i < targetItems.length; i++) {\n      targetItems[i]._refreshSortData();\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Synchronize the item elements to match the order of the items in the DOM.\n   * This comes handy if you need to keep the DOM structure matched with the\n   * order of the items. Note that if an item's element is not currently a child\n   * of the container element (if it is dragged for example) it is ignored and\n   * left untouched.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @returns {Grid}\n   */\n  Grid.prototype.synchronize = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var container = inst._element;\n    var items = inst._items;\n    var fragment;\n    var element;\n    var i;\n\n    // Append all elements in order to the container element.\n    if (items.length) {\n      for (i = 0; i < items.length; i++) {\n        element = items[i]._element;\n        if (element.parentNode === container) {\n          fragment = fragment || doc.createDocumentFragment();\n          fragment.appendChild(element);\n        }\n      }\n      if (fragment) {\n        container.appendChild(fragment);\n      }\n    }\n\n    // Emit synchronize event.\n    inst._emit(evSynchronize);\n\n    return inst;\n\n  };\n\n  /**\n   * Calculate and apply item positions.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {Boolean} [instant=false]\n   * @param {LayoutCallback} [onFinish]\n   * @returns {Grid}\n   */\n  Grid.prototype.layout = function (instant, onFinish) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var callback = typeof instant === typeFunction ? instant : onFinish;\n    var isInstant = instant === true;\n    var items = inst.getItems('active');\n    var layout = inst._layout = new Grid.Layout(inst, items);\n    var counter = items.length;\n    var isBorderBox;\n    var containerStyles;\n    var item;\n    var position;\n    var i;\n\n    // The finish function, which will be used for checking if all the items\n    // have laid out yet. After all items have finished their animations call\n    // callback and emit layoutEnd event. Only emit layoutEnd event if there\n    // hasn't been a new layout call during this layout.\n    function tryFinish() {\n      if (--counter <= 0) {\n        if (typeof callback === typeFunction) {\n          callback(inst._layout !== layout, items.concat());\n        }\n        if (inst._layout === layout) {\n          inst._emit(evLayoutEnd, items.concat());\n        }\n      }\n    }\n\n    // If grid's width or height was modified, we need to update it's cached\n    // dimensions. Also keep in mind that grid's cached width/height should\n    // always equal to what elem.getBoundingClientRect() would return, so\n    // therefore we need to add the grid element's borders to the dimensions if\n    // it's box-sizing is border-box.\n    if (layout.setWidth || layout.setHeight) {\n\n      containerStyles = {};\n      isBorderBox = getStyle(inst._element, 'box-sizing') === 'border-box';\n\n      if (layout.setHeight) {\n        if (typeof layout.height === typeNumber) {\n          containerStyles.height = (isBorderBox ? layout.height + inst._border.top + inst._border.bottom : layout.height) + 'px';\n        }\n        else {\n          containerStyles.height = layout.height;\n        }\n      }\n\n      if (layout.setWidth) {\n        if (typeof layout.width === typeNumber) {\n          containerStyles.width = (isBorderBox ? layout.width + inst._border.left + inst._border.right : layout.width) + 'px';\n        }\n        else {\n          containerStyles.width = layout.width;\n        }\n      }\n\n      setStyles(inst._element, containerStyles);\n\n    }\n\n    // Emit layoutStart event. Note that this is intentionally emitted after the\n    // container element's dimensions are set, because otherwise there would be\n    // no hook for reacting to container dimension changes.\n    inst._emit(evLayoutStart, items.concat());\n\n    // If there are no items let's finish quickly.\n    if (!items.length) {\n      tryFinish();\n      return inst;\n    }\n\n    // If there are items let's position them.\n    for (i = 0; i < items.length; i++) {\n\n      item = items[i];\n      position = layout.slots[item._id];\n\n      // Update item's position.\n      item._left = position.left;\n      item._top = position.top;\n\n      // Layout non-dragged items.\n      if (item.isDragging()) {\n        tryFinish(true, item);\n      }\n      else {\n        item._layout(isInstant, tryFinish);\n      }\n\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Add new items by providing the elements you wish to add to the instance and\n   * optionally provide the index where you want the items to be inserted into.\n   * All elements that are not already children of the container element will be\n   * automatically appended to the container element. If an element has it's CSS\n   * display property set to \"none\" it will be marked as inactive during the\n   * initiation process. As long as the item is inactive it will not be part of\n   * the layout, but it will retain it's index. You can activate items at any\n   * point with grid.show() method. This method will automatically call\n   * grid.layout() if one or more of the added elements are visible. If only\n   * hidden items are added no layout will be called. All the new visible items\n   * are positioned without animation during their first layout.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(HTMLElement|HTMLElement[])} elements\n   * @param {Object} [options]\n   * @param {Number} [options.index=-1]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Item[]}\n   */\n  Grid.prototype.add = function (elements, options) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return [];\n    }\n\n    var targetElements = isNodeList(elements) ? nodeListToArray(elements) : [].concat(elements);\n    var newItems = [];\n\n    // Return early if there are no items.\n    if (!targetElements.length) {\n      return newItems;\n    }\n\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var items = inst._items;\n    var needsLayout = false;\n    var elementIndex;\n    var item;\n    var i;\n\n    // Filter out all elements that exist already in current instance.\n    // TODO: This filtering can be made a lot faster by storing item elements\n    // in a Map or WeakMap. Other option would be to transfer the reponsibility\n    // completely to the user and get rid of this sanity check.\n    for (i = 0; i < items.length; i++) {\n      elementIndex = targetElements.indexOf(items[i]._element);\n      if (elementIndex > -1) {\n        targetElements.splice(elementIndex, 1);\n        if (!targetElements.length) {\n          return newItems;\n        }\n      }\n    }\n\n    // Create new items.\n    for (i = 0; i < targetElements.length; i++) {\n\n      item = new Grid.Item(inst, targetElements[i]);\n      newItems.push(item);\n\n      // If the item to be added is active, we need to do a layout. Also, we\n      // need to mark the item with the skipNextLayoutAnimation flag to make it\n      // position instantly (without animation) during the next layout. Without\n      // the hack the item would animate to it's new position from the northwest\n      // corner of the grid, which feels a bit buggy (imho).\n      if (item._isActive) {\n        needsLayout = true;\n        item._skipNextLayoutAnimation = true;\n      }\n\n    }\n\n    // Add the new items to the items collection to correct index.\n    insertItemsToArray(items, newItems, opts.index);\n\n    // Emit add event.\n    inst._emit(evAdd, newItems.concat());\n\n    // If layout is needed.\n    if (needsLayout && layout) {\n      inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n    }\n\n    // Return new items.\n    return newItems;\n\n  };\n\n  /**\n   * Remove items from the instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.removeElements=false]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Item[]}\n   */\n  Grid.prototype.remove = function (items, options) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var needsLayout = false;\n    var allItems = inst.getItems();\n    var targetItems = inst.getItems(items);\n    var indices = [];\n    var item;\n    var i;\n\n    // Remove the individual items.\n    for (i = 0; i < targetItems.length; i++) {\n      item = targetItems[i];\n      indices.push(allItems.indexOf(item));\n      if (item._isActive) {\n        needsLayout = true;\n      }\n      item._destroy(opts.removeElements);\n    }\n\n    // Emit remove event.\n    inst._emit(evRemove, targetItems.concat(), indices);\n\n    // If layout is needed.\n    if (needsLayout && layout) {\n      inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n    }\n\n    return targetItems;\n\n  };\n\n  /**\n   * Show instance items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {ShowCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.show = function (items, options) {\n\n    return this._isDestroyed ? this : gridShowHideHandler(this, 'show', items, options);\n\n  };\n\n  /**\n   * Hide instance items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {HideCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.hide = function (items, options) {\n\n    return this._isDestroyed ? this : gridShowHideHandler(this, 'hide', items, options);\n\n  };\n\n  /**\n   * Filter items. Expects at least one argument, a predicate, which should be\n   * either a function or a string. The predicate callback is executed for every\n   * item in the instance. If the return value of the predicate is truthy the\n   * item in question will be shown and otherwise hidden. The predicate callback\n   * receives the item instance as it's argument. If the predicate is a string\n   * it is considered to be a selector and it is checked against every item\n   * element in the instance with the native element.matches() method. All the\n   * matching items will be shown and others hidden.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(Function|String)} predicate\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {FilterCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.filter = function (predicate, options) {\n\n    var inst = this;\n\n    // Return immediately if there are no items or if the instance id destroyed.\n    if (inst._isDestroyed || !inst._items.length) {\n      return inst;\n    }\n\n    var items = inst._items;\n    var predicateType = typeof predicate;\n    var isPredicateString = predicateType === typeString;\n    var isPredicateFn = predicateType === typeFunction;\n    var opts = options || {};\n    var isInstant = opts.instant === true;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var onFinish = typeof opts.onFinish === typeFunction ? opts.onFinish : null;\n    var itemsToShow = [];\n    var itemsToHide = [];\n    var tryFinishCounter = -1;\n    var tryFinish = !onFinish ? noop : function () {\n      ++tryFinishCounter && onFinish(itemsToShow.concat(), itemsToHide.concat());\n    };\n    var item;\n    var i;\n\n    // Check which items need to be shown and which hidden.\n    if (isPredicateFn || isPredicateString) {\n      for (i = 0; i < items.length; i++) {\n        item = items[i];\n        if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n          itemsToShow.push(item);\n        }\n        else {\n          itemsToHide.push(item);\n        }\n      }\n    }\n\n    // Show items that need to be shown.\n    if (itemsToShow.length) {\n      inst.show(itemsToShow, {\n        instant: isInstant,\n        onFinish: tryFinish,\n        layout: false\n      });\n    }\n    else {\n      tryFinish();\n    }\n\n    // Hide items that need to be hidden.\n    if (itemsToHide.length) {\n      inst.hide(itemsToHide, {\n        instant: isInstant,\n        onFinish: tryFinish,\n        layout: false\n      });\n    }\n    else {\n      tryFinish();\n    }\n\n    // If there are any items to filter.\n    if (itemsToShow.length || itemsToHide.length) {\n\n      // Emit filter event.\n      inst._emit(evFilter, itemsToShow.concat(), itemsToHide.concat());\n\n      // If layout is needed.\n      if (layout) {\n        inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n      }\n\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Sort items. There are three ways to sort the items. The first is simply by\n   * providing a function as the comparer which works identically to native\n   * array sort. Alternatively you can sort by the sort data you have provided\n   * in the instance's options. Just provide the sort data key(s) as a string\n   * (separated by space) and the items will be sorted based on the provided\n   * sort data keys. Lastly you have the opportunity to provide a presorted\n   * array of items which will be used to sync the internal items array in the\n   * same order.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(Function|Item[]|String|String[])} comparer\n   * @param {Object} [options]\n   * @param {Boolean} [options.descending=false]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.sort = function (comparer, options) {\n\n    var inst = this;\n\n    // Let's not sort if it has no effect.\n    if (inst._isDestroyed || inst._items.length < 2) {\n      return inst;\n    }\n\n    var items = inst._items;\n    var opts = options || {};\n    var isDescending = !!opts.descending;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var origItems = items.concat();\n    var indexMap;\n\n    // If function is provided do a native array sort.\n    if (typeof comparer === typeFunction) {\n      items.sort(function (a, b) {\n        var result = comparer(a, b);\n        return (isDescending && result !== 0 ? -result : result) || compareItemIndices(a, b, isDescending, indexMap || (indexMap = getItemIndexMap(origItems)));\n      });\n    }\n\n    // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof comparer === typeString) {\n      comparer = comparer.trim().split(' ').map(function (val) {\n        return val.split(':');\n      });\n      items.sort(function (a, b) {\n        return compareItems(a, b, isDescending, comparer) || compareItemIndices(a, b, isDescending, indexMap || (indexMap = getItemIndexMap(origItems)));\n      });\n    }\n\n    // Otherwise if we got an array, let's assume it's a presorted array of the\n    // items and order the items based on it.\n    else if (Array.isArray(comparer)) {\n      sortItemsByReference(items, comparer);\n      if (isDescending) {\n        items.reverse();\n      }\n    }\n\n    // Otherwise, let's go home.\n    else {\n      return inst;\n    }\n\n    // Emit sort event.\n    inst._emit(evSort, items.concat(), origItems);\n\n    // If layout is needed.\n    if (layout) {\n      inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Move item to another index or in place of another item.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} item\n   * @param {GridSingleItemQuery} position\n   * @param {Object} [options]\n   * @param {String} [options.action=\"move\"]\n   *   - Accepts either \"move\" or \"swap\".\n   *   - \"move\" moves the item in place of the other item.\n   *   - \"swap\" swaps the position of the items.\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.move = function (item, position, options) {\n\n    var inst = this;\n\n    // Return immediately, if moving an item is not possible.\n    if (inst._isDestroyed || inst._items.length < 2) {\n      return inst;\n    }\n\n    var items = inst._items;\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var isSwap = opts.action === 'swap';\n    var action = isSwap ? 'swap' : 'move';\n    var fromItem = inst._getItem(item);\n    var toItem = inst._getItem(position);\n    var fromIndex;\n    var toIndex;\n\n    // Make sure the items exist and are not the same.\n    if (fromItem && toItem && (fromItem !== toItem)) {\n\n      // Get the indices of the items.\n      fromIndex = items.indexOf(fromItem);\n      toIndex = items.indexOf(toItem);\n\n      // Do the move/swap.\n      (isSwap ? arraySwap : arrayMove)(items, fromIndex, toIndex);\n\n      // Emit move event.\n      inst._emit(evMove, {\n        item: fromItem,\n        fromIndex: fromIndex,\n        toIndex: toIndex,\n        action: action\n      });\n\n      // If layout is needed.\n      if (layout) {\n        inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n      }\n\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Send item to another Grid instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} item\n   * @param {Grid} grid\n   * @param {GridSingleItemQuery} position\n   * @param {Object} [options]\n   * @param {HTMLElement} [options.appendTo=document.body]\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutSender=true]\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutReceiver=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.send = function (item, grid, position, options) {\n\n    var currentGrid = this;\n\n    // Return immediately if either grid is destroyed or if the grids are the\n    // same, or if target item was not found.\n    if (currentGrid._isDestroyed || grid._isDestroyed || currentGrid === grid || !(item = currentGrid._getItem(item))) {\n      return currentGrid;\n    }\n\n    var targetGrid = grid;\n    var opts = options || {};\n    var container = opts.appendTo || body;\n    var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n    var layoutReceiver = opts.layoutReceiver ? opts.layoutReceiver : opts.layoutReceiver === undefined;\n\n    // Start the migration process.\n    item._migrate.start(targetGrid, position, container);\n\n    // If migration was started succesfully and the item is active, let's layout\n    // the grids.\n    if (item._migrate.isActive && item.isActive()) {\n      if (layoutSender) {\n        currentGrid.layout(layoutSender === 'instant', typeof layoutSender === typeFunction ? layoutSender : undefined);\n      }\n      if (layoutReceiver) {\n        targetGrid.layout(layoutReceiver === 'instant', typeof layoutReceiver === typeFunction ? layoutReceiver : undefined);\n      }\n    }\n\n    return currentGrid;\n\n  };\n\n  /**\n   * Destroy the instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {Boolean} [removeElements=false]\n   * @returns {Grid}\n   */\n  Grid.prototype.destroy = function (removeElements) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var container = inst._element;\n    var items = inst._items.concat();\n    var i;\n\n    // Unbind window resize event listener.\n    if (inst._resizeHandler) {\n      global.removeEventListener('resize', inst._resizeHandler);\n    }\n\n    // Destroy items.\n    for (i = 0; i < items.length; i++) {\n      items[i]._destroy(removeElements);\n    }\n\n    // Restore container.\n    removeClass(container, inst._settings.containerClass);\n    setStyles(container, {height: ''});\n\n    // Emit destroy event and unbind all events.\n    inst._emit(evDestroy);\n    inst._emitter.destroy();\n\n    // Remove reference from the grid instances collection.\n    gridInstances[inst._id] = undefined;\n\n    // Flag instance as destroyed.\n    inst._isDestroyed = true;\n\n    return inst;\n\n  };\n\n  /**\n   * Grid - Protected prototype methods\n   * **********************************\n   */\n\n  /**\n   * Get instance's item by element or by index. Target can also be an Item\n   * instance in which case the function returns the item if it exists within\n   * related Grid instance. If nothing is found with the provided target, null\n   * is returned.\n   *\n   * @protected\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} [target=0]\n   * @returns {?Item}\n   */\n  Grid.prototype._getItem = function (target) {\n\n    var inst = this;\n    var items = inst._items;\n    var i;\n\n    // If no target is specified or the instance is destroyed, return the first\n    // item or null.\n    if (inst._isDestroyed || !target) {\n      return items[0] || null;\n    }\n\n    // If target is number return the item in that index. If the number is lower\n    // than zero look for the item starting from the end of the items array. For\n    // example -1 for the last item, -2 for the second last item, etc.\n    else if (typeof target === typeNumber) {\n      return items[target > -1 ? target : items.length + target] || null;\n    }\n\n    // If the target is an instance of Item return it if it is attached to this\n    // Grid instance, otherwise return null.\n    else if (target instanceof Item) {\n      return target._gridId === inst._id ? target : null;\n    }\n\n    // In other cases let's assume that the target is an element, so let's try\n    // to find an item that matches the element and return it. If item is not\n    // found return null.\n    else {\n      // TODO: This could be made a lot faster by using WeakMap or Map.\n      for (i = 0; i < items.length; i++) {\n        if (items[i]._element === target) {\n          return items[i];\n        }\n      }\n      return null;\n    }\n\n  };\n\n  /**\n   * Bind an event listener.\n   *\n   * @protected\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {*} [arg1]\n   * @param {*} [arg2]\n   * @param {*} [arg3]\n   * @returns {Grid}\n   */\n  Grid.prototype._emit = function () {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst._emitter.emit.apply(inst._emitter, arguments);\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Refresh container's internal dimensions.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @returns {Grid}\n   */\n  Grid.prototype._refreshDimensions = function () {\n\n    var inst = this;\n    var element = inst._element;\n    var rect = element.getBoundingClientRect();\n    var sides = ['left', 'right', 'top', 'bottom'];\n    var i;\n\n    inst._width = rect.width;\n    inst._height = rect.height;\n    inst._left = rect.left;\n    inst._top = rect.top;\n    inst._border = {};\n\n    for (i = 0; i < sides.length; i++) {\n      inst._border[sides[i]] = getStyleAsFloat(element, 'border-' + sides[i] + '-width');\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Item\n   * ****\n   */\n\n  /**\n   * Creates a new Item instance for a Grid instance.\n   *\n   * @public\n   * @class\n   * @param {Grid} grid\n   * @param {HTMLElement} element\n   */\n  function Item(grid, element) {\n\n    var inst = this;\n    var settings = grid._settings;\n    var isHidden;\n\n    // Create instance id and add item to the itemInstances collection.\n    inst._id = ++uuid;\n    itemInstances[inst._id] = inst;\n\n    // Destroyed flag.\n    inst._isDestroyed = false;\n\n    // If the provided item element is not a direct child of the grid container\n    // element, append it to the grid container.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n    }\n\n    // Set item class.\n    addClass(element, settings.itemClass);\n\n    // Check if the element is hidden.\n    isHidden = getStyle(element, 'display') === 'none';\n\n    // Set visible/hidden class.\n    addClass(element, isHidden ? settings.itemHiddenClass : settings.itemVisibleClass);\n\n    // Refrence to connected Grid instance's id.\n    inst._gridId = grid._id;\n\n    // The elements.\n    inst._element = element;\n    inst._child = element.children[0];\n\n    // Initiate item's animation controllers.\n    inst._animate = new Grid.ItemAnimate(inst, element);\n    inst._animateChild = new Grid.ItemAnimate(inst, inst._child);\n\n    // Set up active state (defines if the item is considered part of the layout\n    // or not).\n    inst._isActive = isHidden ? false : true;\n\n    // Set up positioning state (defines if the item is currently animating\n    // it's position).\n    inst._isPositioning = false;\n\n    // Set up visibility states.\n    inst._isHidden = isHidden;\n    inst._isHiding = false;\n    inst._isShowing = false;\n\n    // Visibility animation callback queue. Whenever a callback is provided for\n    // show/hide methods and animation is enabled the callback is stored\n    // temporarily to this array. The callbacks are called with the first\n    // argument as false if the animation succeeded without interruptions and\n    // with the first argument as true if the animation was interrupted.\n    inst._visibilityQueue = [];\n\n    // Layout animation callback queue. Whenever a callback is provided for\n    // layout method and animation is enabled the callback is stored temporarily\n    // to this array. The callbacks are called with the first argument as false\n    // if the animation succeeded without interruptions and with the first\n    // argument as true if the animation was interrupted.\n    inst._layoutQueue = [];\n\n    // Set up initial positions.\n    inst._left = 0;\n    inst._top = 0;\n\n    // Set element's initial styles.\n    setStyles(element, {\n      left: '0',\n      top: '0',\n      transform: getTranslateString(0, 0),\n      display: isHidden ? 'none' : 'block'\n    });\n\n    // Set up the initial dimensions and sort data.\n    inst._refreshDimensions()._refreshSortData();\n\n    // Set initial styles for the child element.\n    if (isHidden) {\n      grid._itemHideHandler.start(inst, true);\n    }\n    else {\n      grid._itemShowHandler.start(inst, true);\n    }\n\n    // Set up migration handler data.\n    inst._migrate = new Grid.ItemMigrate(inst);\n\n    // Set up release handler\n    inst._release = new Grid.ItemRelease(inst);\n\n    // Set up drag handler.\n    inst._drag = settings.dragEnabled ? new Grid.ItemDrag(inst) : null;\n\n  }\n\n  /**\n   * Item - Public prototype methods\n   * *******************************\n   */\n\n  /**\n   * Get the instance grid reference.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Grid}\n   */\n  Item.prototype.getGrid = function () {\n\n    return gridInstances[this._gridId];\n\n  };\n\n  /**\n   * Get the instance element.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {HTMLElement}\n   */\n  Item.prototype.getElement = function () {\n\n    return this._element;\n\n  };\n\n  /**\n   * Get instance element's cached width.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Number}\n   */\n  Item.prototype.getWidth = function () {\n\n    return this._width;\n\n  };\n\n  /**\n   * Get instance element's cached height.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Number}\n   */\n  Item.prototype.getHeight = function () {\n\n    return this._height;\n\n  };\n\n  /**\n   * Get instance element's cached margins.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Object}\n   *   - The returned object contains left, right, top and bottom properties\n   *     which indicate the item element's cached margins.\n   */\n  Item.prototype.getMargin = function () {\n\n    return {\n      left: this._margin.left,\n      right: this._margin.right,\n      top: this._margin.top,\n      bottom: this._margin.bottom\n    };\n\n  };\n\n  /**\n   * Get instance element's cached position.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Object}\n   *   - The returned object contains left and top properties which indicate the\n   *     item element's cached position in the grid.\n   */\n  Item.prototype.getPosition = function () {\n\n    return {\n      left: this._left,\n      top: this._top\n    };\n\n  };\n\n  /**\n   * Is the item active?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isActive = function () {\n\n    return this._isActive;\n\n  };\n\n  /**\n   * Is the item visible?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isVisible = function () {\n\n    return !this._isHidden;\n\n  };\n\n  /**\n   * Is the item being animated to visible?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isShowing = function () {\n\n    return this._isShowing;\n\n  };\n\n  /**\n   * Is the item being animated to hidden?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isHiding = function () {\n\n    return this._isHiding;\n\n  };\n\n  /**\n   * Is the item positioning?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isPositioning = function () {\n\n    return this._isPositioning;\n\n  };\n\n  /**\n   * Is the item being dragged?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isDragging = function () {\n\n    return !!this._drag && this._drag._data.isActive;\n\n  };\n\n  /**\n   * Is the item being released?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isReleasing = function () {\n\n    return this._release.isActive;\n\n  };\n\n  /**\n   * Is the item destroyed?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isDestroyed = function () {\n\n    return this._isDestroyed;\n\n  };\n\n  /**\n   * Item - Protected prototype methods\n   * **********************************\n   */\n\n  /**\n   * Recalculate item's dimensions.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @returns {Item}\n   */\n  Item.prototype._refreshDimensions = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed || inst._isHidden) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var rect = element.getBoundingClientRect();\n    var sides = ['left', 'right', 'top', 'bottom'];\n    var margin = inst._margin = inst._margin || {};\n    var side;\n    var i;\n\n    // Calculate width and height.\n    inst._width = rect.width;\n    inst._height = rect.height;\n\n    // Calculate margins (ignore negative margins).\n    for (i = 0; i < 4; i++) {\n      side = getStyleAsFloat(element, 'margin-' + sides[i]);\n      margin[sides[i]] = side > 0 ? side : 0;\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Fetch and store item's sort data.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @returns {Item}\n   */\n  Item.prototype._refreshSortData = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var sortData = {};\n    var getters = inst.getGrid()._settings.sortData;\n\n    // Fetch sort data.\n    if (getters) {\n      Object.keys(getters).forEach(function (key) {\n        sortData[key] = getters[key](inst, inst._element);\n      });\n    }\n\n    // Store sort data to the instance.\n    inst._sortData = sortData;\n\n    return inst;\n\n  };\n\n  /**\n   * Position item based on it's current data.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} instant\n   * @param {Function} [onFinish]\n   * @returns {Item}\n   */\n  Item.prototype._layout = function (instant, onFinish) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var isPositioning = inst._isPositioning;\n    var migrate = inst._migrate;\n    var release = inst._release;\n    var isJustReleased = release.isActive && release.isPositioningStarted === false;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n    var animDuration = isJustReleased ? settings.dragReleaseDuration : settings.layoutDuration;\n    var animEasing = isJustReleased ? settings.dragReleaseEasing : settings.layoutEasing;\n    var animEnabled = !instant && !inst._skipNextLayoutAnimation && animDuration > 0;\n    var isAnimating;\n    var offsetLeft;\n    var offsetTop;\n    var currentLeft;\n    var currentTop;\n    var targetStyles;\n\n    // If the item is currently positioning process current layout callback\n    // queue with interrupted flag on if the item is currently positioning.\n    if (isPositioning) {\n      processQueue(inst._layoutQueue, true, inst);\n    }\n\n    // Mark release positioning as started.\n    if (isJustReleased) {\n      release.isPositioningStarted = true;\n    }\n\n    // Push the callback to the callback queue.\n    if (typeof onFinish === typeFunction) {\n      inst._layoutQueue.push(onFinish);\n    }\n\n    // Get item container offsets and target styles.\n    offsetLeft = release.isActive ? release.containerDiffX : migrate.isActive ? migrate.containerDiffX : 0;\n    offsetTop = release.isActive ? release.containerDiffY : migrate.isActive ? migrate.containerDiffY : 0;\n    targetStyles = {transform: getTranslateString(inst._left + offsetLeft, inst._top + offsetTop)};\n\n    // If no animations are needed, easy peasy!\n    if (!animEnabled) {\n      isPositioning && rafLoop.cancel(rafQueueLayout, inst._id);\n      isAnimating = inst._animate.isAnimating();\n      inst._stopLayout(false, targetStyles);\n      !isAnimating && setStyles(element, targetStyles);\n      inst._skipNextLayoutAnimation = false;\n      return inst._finishLayout();\n    }\n\n    // Set item as positioning.\n    inst._isPositioning = true;\n\n    // Get the element's current left and top position in the read callback.\n    // Then in the write callback do the animation if necessary.\n    rafLoop.add(rafQueueLayout, inst._id, function () {\n      currentLeft = getTranslateAsFloat(element, 'x') - offsetLeft;\n      currentTop = getTranslateAsFloat(element, 'y') - offsetTop;\n    }, function () {\n\n      // If the item is already in correct position let's quit early.\n      if (inst._left === currentLeft && inst._top === currentTop) {\n        isPositioning && inst._stopLayout(false, targetStyles);\n        inst._isPositioning = false;\n        return inst._finishLayout();\n      }\n\n      // Set item's positioning class.\n      !isPositioning && addClass(element, settings.itemPositioningClass);\n\n      // Animate.\n      inst._animate.start(\n        {transform: getTranslateString(currentLeft + offsetLeft, currentTop + offsetTop)},\n        targetStyles,\n        {\n          duration: animDuration,\n          easing: animEasing,\n          onFinish: function () {\n            inst._finishLayout();\n          }\n        }\n      );\n\n    });\n\n    return inst;\n\n  };\n\n  /**\n   * Position item based on it's current data.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @returns {Item}\n   */\n  Item.prototype._finishLayout = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    // Mark the item as not positioning and remove positioning classes.\n    if (inst._isPositioning) {\n      inst._isPositioning = false;\n      removeClass(inst._element, inst.getGrid()._settings.itemPositioningClass);\n    }\n\n    // Finish up release.\n    if (inst._release.isActive) {\n      inst._release.stop();\n    }\n\n    // Finish up migration.\n    if (inst._migrate.isActive) {\n      inst._migrate.stop();\n    }\n\n    // Process the callback queue.\n    processQueue(inst._layoutQueue, false, inst);\n\n    return inst;\n\n  };\n\n  /**\n   * Stop item's position animation if it is currently animating.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} [processLayoutQueue=false]\n   * @param {Object} [targetStyles]\n   * @returns {Item}\n   */\n  Item.prototype._stopLayout = function (processLayoutQueue, targetStyles) {\n\n    var inst = this;\n\n    if (inst._isDestroyed || !inst._isPositioning) {\n      return inst;\n    }\n\n    // Cancel animation init.\n    rafLoop.cancel(rafQueueLayout, inst._id);\n\n    // Stop animation.\n    inst._animate.stop(targetStyles);\n\n    // Remove positioning class.\n    removeClass(inst._element, inst.getGrid()._settings.itemPositioningClass);\n\n    // Reset state.\n    inst._isPositioning = false;\n\n    // Process callback queue.\n    if (processLayoutQueue) {\n      processQueue(inst._layoutQueue, true, inst);\n    }\n\n    return inst;\n\n  };\n\n  Item.prototype._show = function (instant, onFinish) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var queue = inst._visibilityQueue;\n    var callback = typeof onFinish === typeFunction ? onFinish : null;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n\n    // If item is visible call the callback and be done with it.\n    if (!inst._isShowing && !inst._isHidden) {\n      callback && callback(false, inst);\n      return inst;\n    }\n\n    // If item is showing and does not need to be shown instantly, let's just\n    // push callback to the callback queue and be done with it.\n    if (inst._isShowing && !instant) {\n      callback && queue.push(callback);\n      return inst;\n    }\n\n    // If the item is hiding or hidden process the current visibility callback\n    // queue with the interrupted flag active, update classes and set display\n    // to block if necessary.\n    if (!inst._isShowing) {\n      processQueue(queue, true, inst);\n      removeClass(element, settings.itemHiddenClass);\n      addClass(element, settings.itemVisibleClass);\n      !inst._isHiding && setStyles(element, {display: 'block'});\n    }\n\n    // Push callback to the callback queue.\n    callback && queue.push(callback);\n\n    // Update item's internal states.\n    inst._isActive = inst._isShowing = true;\n    inst._isHiding = inst._isHidden = false;\n\n    // If we need to show instantly.\n    if (instant) {\n      grid._itemShowHandler.stop(inst, settings.visibleStyles);\n      inst._isShowing = false;\n      processQueue(queue, false, inst);\n    }\n\n    // If we need to animate.\n    else {\n      grid._itemShowHandler.start(inst, instant, function () {\n        if (!inst._isHidden) {\n          inst._isShowing = false;\n          processQueue(queue, false, inst);\n        }\n      });\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Hide item.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} instant\n   * @param {Function} [onFinish]\n   * @returns {Item}\n   */\n  Item.prototype._hide = function (instant, onFinish) {\n\n    var inst = this;\n\n    // Return immediately if the instance is destroyed.\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var queue = inst._visibilityQueue;\n    var callback = typeof onFinish === typeFunction ? onFinish : null;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n\n    // If item is already hidden call the callback and be done with it.\n    if (!inst._isHiding && inst._isHidden) {\n      callback && callback(false, inst);\n      return inst;\n    }\n\n    // If item is hiding and does not need to be hidden instantly, let's just\n    // push callback to the callback queue and be done with it.\n    if (inst._isHiding && !instant) {\n      callback && queue.push(callback);\n      return inst;\n    }\n\n    // If the item is showing or visible process the current visibility callback\n    // queue with the interrupted flag active, update classes and set display\n    // to block if necessary.\n    if (!inst._isHiding) {\n      processQueue(queue, true, inst);\n      addClass(element, settings.itemHiddenClass);\n      removeClass(element, settings.itemVisibleClass);\n    }\n\n    // Push callback to the callback queue.\n    callback && queue.push(callback);\n\n    // Update item's internal states.\n    inst._isHidden = inst._isHiding = true;\n    inst._isActive = inst._isShowing = false;\n\n    // If we need to hide instantly.\n    if (instant) {\n      grid._itemHideHandler.stop(inst, settings.hiddenStyles);\n      inst._isHiding = false;\n      inst._stopLayout(true, {transform: getTranslateString(0, 0)});\n      setStyles(element, {display: 'none'});\n      processQueue(queue, false, inst);\n    }\n\n    // If we need to animate.\n    else {\n      grid._itemHideHandler.start(inst, instant, function () {\n        if (inst._isHidden) {\n          inst._isHiding = false;\n          inst._stopLayout(true, {transform: getTranslateString(0, 0)});\n          setStyles(element, {display: 'none'});\n          processQueue(queue, false, inst);\n        }\n      });\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Destroy item instance.\n   *\n   * @protected\n   * @memberof Item.prototype\n   * @param {Boolean} [removeElement=false]\n   * @returns {Item}\n   */\n  Item.prototype._destroy = function (removeElement) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var element = inst._element;\n    var grid = inst.getGrid();\n    var settings = grid._settings;\n    var index = grid._items.indexOf(inst);\n\n    // Destroy release and migration.\n    inst._release.destroy();\n    inst._migrate.destroy();\n\n    // Stop animations.\n    inst._stopLayout(true, {});\n    grid._itemShowHandler.stop(inst, {});\n    grid._itemHideHandler.stop(inst, {});\n\n    // Destroy drag.\n    inst._drag && inst._drag.destroy();\n\n    // Destroy animation handlers.\n    inst._animate.destroy();\n    inst._animateChild.destroy();\n\n    // Handle visibility callback queue, fire all uncompleted callbacks with\n    // interrupted flag.\n    processQueue(inst._visibilityQueue, true, inst);\n\n    // Remove all inline styles.\n    element.removeAttribute('style');\n    inst._child.removeAttribute('style');\n\n    // Remove classes.\n    removeClass(element, settings.itemPositioningClass);\n    removeClass(element, settings.itemDraggingClass);\n    removeClass(element, settings.itemReleasingClass);\n    removeClass(element, settings.itemClass);\n    removeClass(element, settings.itemVisibleClass);\n    removeClass(element, settings.itemHiddenClass);\n\n    // Remove item from Grid instance if it still exists there.\n    index > -1 && grid._items.splice(index, 1);\n\n    // Remove element from DOM.\n    removeElement && element.parentNode.removeChild(element);\n\n    // Remove item instance from the item instances collection.\n    itemInstances[inst._id] = undefined;\n\n    // Update item states (mostly just for good measure).\n    inst._isActive = inst._isPositioning = inst._isHiding = inst._isShowing = false;\n    inst._isDestroyed = inst._isHidden = true;\n\n    return inst;\n\n  };\n\n  /**\n   * Layout\n   * ******\n   */\n\n  /**\n   * Creates a new Layout instance.\n   *\n   * @public\n   * @class\n   * @param {Grid} grid\n   * @param {Item[]} items\n   */\n  function Layout(grid, items) {\n\n    var inst = this;\n    var layoutSettings = grid._settings.layout;\n\n    // Clone items.\n    items = items.concat();\n\n    // Let's make sure we have the correct container dimensions before going\n    // further.\n    grid._refreshDimensions();\n\n    var width = grid._width - grid._border.left - grid._border.right;\n    var height = grid._height - grid._border.top - grid._border.bottom;\n    var isCustomLayout = typeof layoutSettings === typeFunction;\n    var layout = isCustomLayout ? layoutSettings(items, width, height) :\n      muuriLayout(items, width, height, isPlainObject(layoutSettings) ? layoutSettings : {});\n\n    // Set instance data based on layout data.\n    inst.slots = layout.slots;\n    inst.setWidth = layout.setWidth || false;\n    inst.setHeight = layout.setHeight || false;\n    inst.width = layout.width;\n    inst.height = layout.height;\n\n  }\n\n  /**\n   * Emitter\n   * *******\n   */\n\n  /**\n   * Event emitter constructor.\n   *\n   * @public\n   * @class\n   */\n  function Emitter() {\n\n    this._events = {};\n    this._isDestroyed = false;\n\n  }\n\n  /**\n   * Emitter - Public prototype methods\n   * **********************************\n   */\n\n  /**\n   * Bind an event listener.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.on = function (event, listener) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var listeners = inst._events[event] || [];\n    listeners.push(listener);\n    inst._events[event] = listeners;\n\n    return inst;\n\n  };\n\n  /**\n   * Bind an event listener that is triggered only once.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.once = function (event, listener) {\n\n    var inst = this;\n    return this.on(event, function callback() {\n      inst.off(event, callback);\n      listener.apply(null, arguments);\n    });\n\n  };\n\n  /**\n   * Unbind all event listeners that match the provided listener function.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.off = function (event, listener) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var listeners = inst._events[event] || [];\n    var i = listeners.length;\n\n    while (i--) {\n      if (listener === listeners[i]) {\n        listeners.splice(i, 1);\n      }\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Emit all listeners in a specified event with the provided arguments.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {*} [arg1]\n   * @param {*} [arg2]\n   * @param {*} [arg3]\n   * @returns {Emitter}\n   */\n  Emitter.prototype.emit = function (event, arg1, arg2, arg3) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var listeners = inst._events[event] || [];\n    var listenersLength = listeners.length;\n    var argsLength = arguments.length - 1;\n    var i;\n\n    if (listenersLength) {\n      listeners = listeners.concat();\n      for (i = 0; i < listenersLength; i++) {\n        argsLength === 0 ? listeners[i]() :\n        argsLength === 1 ? listeners[i](arg1) :\n        argsLength === 2 ? listeners[i](arg1, arg2) :\n                            listeners[i](arg1, arg2, arg3);\n      }\n    }\n\n    return inst;\n\n  };\n\n  /**\n   * Destroy emitter instance. Basically just removes all bound listeners.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @returns {Emitter}\n   */\n  Emitter.prototype.destroy = function () {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return inst;\n    }\n\n    var eventNames = Object.keys(inst._events);\n    var i;\n\n    for (i = 0; i < eventNames.length; i++) {\n      inst._events[eventNames[i]] = null;\n    }\n\n    inst._isDestroyed = true;\n\n    return inst;\n\n  };\n\n  /**\n   * ItemAnimate\n   * ***********\n   */\n\n  /**\n   * Muuri's internal animation engine. Uses Web Animations API.\n   *\n   * @public\n   * @class\n   * @param {Item} item\n   * @param {HTMLElement} element\n   */\n  function ItemAnimate(item, element) {\n\n    var inst = this;\n    inst._item = item;\n    inst._element = element;\n    inst._animation = null;\n    inst._propsTo = null;\n    inst._isDestroyed = false;\n\n  }\n\n  /**\n   * ItemAnimate - Public prototype methods\n   * **************************************\n   */\n\n  /**\n   * Start instance's animation. Automatically stops current animation if it is\n   * running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @param {Object} propsFrom\n   * @param {Object} propsTo\n   * @param {Object} [options]\n   * @param {Number} [options.duration=300]\n   * @param {String} [options.easing='ease']\n   * @param {Function} [options.onFinish]\n   */\n  ItemAnimate.prototype.start = function (propsFrom, propsTo, options) {\n\n    var inst = this;\n\n    if (inst._isDestroyed) {\n      return;\n    }\n\n    var opts = options || {};\n    var callback = typeof opts.onFinish === typeFunction ? opts.onFinish : null;\n    var shouldStop;\n\n    // If item is being animate check if the target animation properties equal\n    // to the properties in the current animation. If they match we can just let\n    // the animation continue and be done with it (and of course change the\n    // cached callback). If the animation properties do not match we need to\n    // stop the ongoing animation.\n    if (inst._animation) {\n      shouldStop = Object.keys(propsTo).some(function (propName) {\n        return propsTo[propName] !== inst._propsTo[propName];\n      });\n      if (shouldStop) {\n        inst._animation.cancel();\n      }\n      else {\n        inst._animation.onfinish = function () {\n          inst._animation = inst._propsTo = null;\n          callback && callback();\n        };\n        return;\n      }\n    }\n\n    // Cache target props.\n    inst._propsTo = propsTo;\n\n    // Start the animation.\n    inst._animation = inst._element.animate([propsFrom, propsTo], {\n      duration: opts.duration || 300,\n      easing: opts.easing || 'ease'\n    });\n\n    // Bind animation finish callback.\n    inst._animation.onfinish = function () {\n      inst._animation = inst._propsTo = null;\n      callback && callback();\n    };\n\n    // Set the end styles.\n    setStyles(inst._element, propsTo);\n\n  };\n\n  /**\n   * Stop instance's current animation if running.\n   *\n   * @private\n   * @memberof ItemAnimate.prototype\n   * @param {Object} [currentProps]\n   */\n  ItemAnimate.prototype.stop = function (currentProps) {\n\n    var inst = this;\n\n    if (!inst._isDestroyed && inst._animation) {\n      setStyles(inst._element, currentProps || getCurrentStyles(inst._element, inst._propsTo));\n      inst._animation.cancel();\n      inst._animation = inst._propsTo = null;\n    }\n\n  };\n\n  /**\n   * Check if the item is being animated currently.\n   *\n   * @private\n   * @memberof ItemAnimate.prototype\n   * @return {Boolean}\n   */\n  ItemAnimate.prototype.isAnimating = function () {\n\n    return !!this._animation;\n\n  };\n\n  /**\n   * Destroy the instance and stop current animation if it is running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @returns {Boolean}\n   */\n  ItemAnimate.prototype.destroy = function () {\n\n    var inst = this;\n\n    if (!inst._isDestroyed) {\n      inst.stop();\n      inst._item = inst._element = null;\n      inst._isDestroyed = true;\n    }\n\n  };\n\n  /**\n   * ItemMigrate\n   * ***********\n   */\n\n  /**\n   * The migrate process handler constructor.\n   *\n   * @class\n   * @private\n   * @param {Item} item\n   */\n  function ItemMigrate(item) {\n\n    var migrate = this;\n\n    // Private props.\n    migrate._itemId = item._id;\n    migrate._isDestroyed = false;\n\n    // Public props.\n    migrate.isActive = false;\n    migrate.container = false;\n    migrate.containerDiffX = 0;\n    migrate.containerDiffY = 0;\n\n  }\n\n  /**\n   * ItemMigrate - Public prototype methods\n   * **************************************\n   */\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.destroy = function () {\n\n    var migrate = this;\n\n    if (!migrate._isDestroyed) {\n      migrate.stop(true);\n      migrate._isDestroyed = true;\n    }\n\n    return migrate;\n\n  };\n\n  /**\n   * Get Item instance.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @returns {?Item}\n   */\n  ItemMigrate.prototype.getItem = function () {\n\n    return itemInstances[this._itemId] || null;\n\n  };\n\n  /**\n   * Start the migrate process of an item.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @param {Grid} targetGrid\n   * @param {GridSingleItemQuery} position\n   * @param {HTMLElement} [container]\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.start = function (targetGrid, position, container) {\n\n    var migrate = this;\n\n    if (migrate._isDestroyed) {\n      return migrate;\n    }\n\n    var item = migrate.getItem();\n    var itemElement = item._element;\n    var isItemVisible = item.isVisible();\n    var currentGrid = item.getGrid();\n    var currentGridStn = currentGrid._settings;\n    var targetGridStn = targetGrid._settings;\n    var targetGridElement = targetGrid._element;\n    var currentIndex = currentGrid._items.indexOf(item);\n    var targetIndex = typeof position === typeNumber ? position : targetGrid._items.indexOf(targetGrid._getItem(position));\n    var targetContainer = container || body;\n    var currentContainer;\n    var offsetDiff;\n    var containerDiff;\n    var translateX;\n    var translateY;\n\n    // If we have invalid new index, let's return immediately.\n    if (targetIndex === null) {\n      return migrate;\n    }\n\n    // Normalize target index (for event data).\n    targetIndex = normalizeArrayIndex(targetGrid._items, targetIndex, true);\n\n    // Get current translateX and translateY values if needed.\n    if (item.isPositioning() || migrate.isActive || item.isReleasing()) {\n      translateX = getTranslateAsFloat(itemElement, 'x');\n      translateY = getTranslateAsFloat(itemElement, 'y');\n    }\n\n    // Abort current positioning.\n    if (item.isPositioning()) {\n      item._stopLayout(true, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Abort current migration.\n    if (migrate.isActive) {\n      translateX -= migrate.containerDiffX;\n      translateY -= migrate.containerDiffY;\n      migrate.stop(true, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Abort current release.\n    if (item.isReleasing()) {\n      translateX -= item._release.containerDiffX;\n      translateY -= item._release.containerDiffY;\n      item._release.stop(true, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Stop current visibility animations.\n    // TODO: This causes potentially layout thrashing, because we are not\n    // feeding any styles to the stop handlers.\n    currentGrid._itemShowHandler.stop(item);\n    currentGrid._itemHideHandler.stop(item);\n\n    // Destroy current drag.\n    if (item._drag) {\n      item._drag.destroy();\n    }\n\n    // Destroy current animation handlers.\n    item._animate.destroy();\n    item._animateChild.destroy();\n\n    // Process current visibility animation queue.\n    processQueue(item._visibilityQueue, true, item);\n\n    // Emit beforeSend event.\n    currentGrid._emit(evBeforeSend, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    // Emit beforeReceive event.\n    targetGrid._emit(evBeforeReceive, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    // Remove current classnames.\n    removeClass(itemElement, currentGridStn.itemClass);\n    removeClass(itemElement, currentGridStn.itemVisibleClass);\n    removeClass(itemElement, currentGridStn.itemHiddenClass);\n\n    // Add new classnames.\n    addClass(itemElement, targetGridStn.itemClass);\n    addClass(itemElement, isItemVisible ? targetGridStn.itemVisibleClass : targetGridStn.itemHiddenClass);\n\n    // Move item instance from current grid to target grid.\n    currentGrid._items.splice(currentIndex, 1);\n    insertItemsToArray(targetGrid._items, item, targetIndex);\n\n    // Update item's grid id reference.\n    item._gridId = targetGrid._id;\n\n    // Instantiate new animation controllers.\n    item._animate = new Grid.ItemAnimate(item, itemElement);\n    item._animateChild = new Grid.ItemAnimate(item, item._child);\n\n    // Get current container\n    currentContainer = itemElement.parentNode;\n\n    // Move the item inside the target container if it's different than the\n    // current container.\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(itemElement);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n      if (translateX === undefined) {\n        translateX = getTranslateAsFloat(itemElement, 'x');\n        translateY = getTranslateAsFloat(itemElement, 'y');\n      }\n      setStyles(itemElement, {transform: getTranslateString(translateX + offsetDiff.left, translateY + offsetDiff.top)});\n    }\n\n    // Update child element's styles to reflect the current visibility state.\n    item._child.removeAttribute('style');\n    if (isItemVisible) {\n      targetGrid._itemShowHandler.start(item, true);\n    }\n    else {\n      targetGrid._itemHideHandler.start(item, true);\n    }\n\n    // Update display styles.\n    setStyles(itemElement, {\n      display: isItemVisible ? 'block' : 'hidden'\n    });\n\n    // Get offset diff for the migration data.\n    containerDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n\n    // Update item's cached dimensions and sort data.\n    item._refreshDimensions()._refreshSortData();\n\n    // Create new drag handler.\n    item._drag = targetGridStn.dragEnabled ? new Grid.ItemDrag(item) : null;\n\n    // Setup migration data.\n    migrate.isActive = true;\n    migrate.container = targetContainer;\n    migrate.containerDiffX = containerDiff.left;\n    migrate.containerDiffY = containerDiff.top;\n\n    // Emit send event.\n    currentGrid._emit(evSend, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    // Emit receive event.\n    targetGrid._emit(evReceive, {\n      item: item,\n      fromGrid: currentGrid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n\n    return migrate;\n\n  };\n\n  /**\n   * End the migrate process of an item. This method can be used to abort an\n   * ongoing migrate process (animation) or finish the migrate process.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @param {Boolean} [abort=false]\n   *  - Should the migration be aborted?\n   * @param {Object} [currentStyles]\n   *  - Optional current translateX and translateY styles.\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.stop = function (abort, currentStyles) {\n\n    var migrate = this;\n\n    if (migrate._isDestroyed || !migrate.isActive) {\n      return migrate;\n    }\n\n    var item = migrate.getItem();\n    var element = item._element;\n    var grid = item.getGrid();\n    var gridElement = grid._element;\n    var translateX;\n    var translateY;\n\n    if (migrate.container !== gridElement) {\n      if (!currentStyles) {\n        translateX = abort ? getTranslateAsFloat(element, 'x') - migrate.containerDiffX : item._left;\n        translateY = abort ? getTranslateAsFloat(element, 'y') - migrate.containerDiffY : item._top;\n        currentStyles = {transform: getTranslateString(translateX, translateY)};\n      }\n      gridElement.appendChild(element);\n      setStyles(element, currentStyles);\n    }\n\n    migrate.isActive = false;\n    migrate.container = null;\n    migrate.containerDiffX = 0;\n    migrate.containerDiffY = 0;\n\n    return migrate;\n\n  };\n\n  /**\n   * ItemRelease\n   * ***********\n   */\n\n  /**\n   * The release process handler constructor. Although this might seem as proper\n   * fit for the drag process this needs to be separated into it's own logic\n   * because there might be a scenario where drag is disabled, but the release\n   * process still needs to be implemented (dragging from a grid to another).\n   *\n   * @class\n   * @private\n   * @param {Item} item\n   */\n  function ItemRelease(item) {\n\n    var release = this;\n\n    // Private props.\n    release._itemId = item._id;\n    release._isDestroyed = false;\n\n    // Public props.\n    release.isActive = false;\n    release.isPositioningStarted = false;\n    release.containerDiffX = 0;\n    release.containerDiffY = 0;\n\n  }\n\n  /**\n   * ItemRelease - Public prototype methods\n   * **************************************\n   */\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.destroy = function () {\n\n    var release = this;\n\n    if (!release._isDestroyed) {\n      release.stop(true);\n      release._isDestroyed = true;\n    }\n\n    return release;\n\n  };\n\n  /**\n   * Get Item instance.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {?Item}\n   */\n  ItemRelease.prototype.getItem = function () {\n\n    return itemInstances[this._itemId] || null;\n\n  };\n\n  /**\n   * Reset public data and remove releasing class.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.reset = function () {\n\n    var release = this;\n\n    if (release._isDestroyed) {\n      return release;\n    }\n\n    var item = release.getItem();\n    release.isActive = false;\n    release.isPositioningStarted = false;\n    release.containerDiffX = 0;\n    release.containerDiffY = 0;\n    removeClass(item._element, item.getGrid()._settings.itemReleasingClass);\n\n    return release;\n\n  };\n\n  /**\n   * Start the release process of an item.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.start = function () {\n\n    var release = this;\n\n    if (release._isDestroyed || release.isActive) {\n      return release;\n    }\n\n    var item = release.getItem();\n    var grid = item.getGrid();\n\n    // Flag release as active.\n    release.isActive = true;\n\n    // Add release classname to the released element.\n    addClass(item._element, grid._settings.itemReleasingClass);\n\n    // Emit dragReleaseStart event.\n    grid._emit(evDragReleaseStart, item);\n\n    // Position the released item.\n    item._layout(false);\n\n    return release;\n\n  };\n\n  /**\n   * End the release process of an item. This method can be used to abort an\n   * ongoing release process (animation) or finish the release process.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @param {Boolean} [abort=false]\n   *  - Should the release be aborted? When true, the release end event won't be\n   *    emitted. Set to true only when you need to abort the release process\n   *    while the item is animating to it's position.\n   * @param {Object} [currentStyles]\n   *  - Optional current translateX and translateY styles.\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.stop = function (abort, currentStyles) {\n\n    var release = this;\n\n    if (release._isDestroyed || !release.isActive) {\n      return release;\n    }\n\n    var item = release.getItem();\n    var element = item._element;\n    var grid = item.getGrid();\n    var container = grid._element;\n    var containerDiffX = release.containerDiffX;\n    var containerDiffY = release.containerDiffY;\n    var translateX;\n    var translateY;\n\n    // Reset data and remove releasing classname from the element.\n    release.reset();\n\n    // If the released element is outside the grid's container element put it\n    // back there and adjust position accordingly.\n    if (element.parentNode !== container) {\n      if (!currentStyles) {\n        translateX = abort ? getTranslateAsFloat(element, 'x') - containerDiffX : item._left;\n        translateY = abort ? getTranslateAsFloat(element, 'y') - containerDiffY : item._top;\n        currentStyles = {transform: getTranslateString(translateX, translateY)};\n      }\n      container.appendChild(element);\n      setStyles(element, currentStyles);\n    }\n\n    // Emit dragReleaseEnd event.\n    if (!abort) {\n      grid._emit(evDragReleaseEnd, item);\n    }\n\n    return release;\n\n  };\n\n  /**\n   * ItemDrag\n   * ********\n   */\n\n  /**\n   * Bind Hammer touch interaction to an item.\n   *\n   * @class\n   * @private\n   * @param {Item} item\n   */\n  function ItemDrag(item) {\n\n    if (!Hammer) {\n      throw new Error('[' + namespace + '] required dependency Hammer is not defined.');\n    }\n\n    var drag = this;\n    var element = item._element;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n    var hammer;\n\n    // Start predicate.\n    var startPredicate = typeof settings.dragStartPredicate === typeFunction ?\n      settings.dragStartPredicate : ItemDrag.defaultStartPredicate;\n    var startPredicateState = startPredicateInactive;\n    var startPredicateResult;\n\n    // Protected data.\n    drag._itemId = item._id;\n    drag._gridId = grid._id;\n    drag._hammer = hammer = new Hammer.Manager(element);\n    drag._isDestroyed = false;\n    drag._isMigrating = false;\n    drag._data = {};\n\n    // Create a private drag start resolver that can be used to resolve the drag\n    // start predicate asynchronously.\n    drag._resolveStartPredicate = function (event) {\n      if (!drag._isDestroyed && startPredicateState === startPredicatePending) {\n        startPredicateState = startPredicateResolved;\n        drag.onStart(event);\n      }\n    };\n\n    // Create scroll listener.\n    drag._scrollListener = function (e) {\n      drag.onScroll(e);\n    };\n\n    // Create overlap checker function.\n    drag._checkSortOverlap = debounce(function () {\n      drag._data.isActive && drag.checkOverlap();\n    }, settings.dragSortInterval);\n\n    // Create sort predicate.\n    drag._sortPredicate = typeof settings.dragSortPredicate === typeFunction ?\n      settings.dragSortPredicate : ItemDrag.defaultSortPredicate;\n\n    // Setup item's initial drag data.\n    drag.reset();\n\n    // Add drag recognizer to hammer.\n    hammer.add(new Hammer.Pan({\n      event: 'drag',\n      pointers: 1,\n      threshold: 0,\n      direction: Hammer.DIRECTION_ALL\n    }));\n\n    // Add draginit recognizer to hammer.\n    hammer.add(new Hammer.Press({\n      event: 'draginit',\n      pointers: 1,\n      threshold: 1000,\n      time: 0\n    }));\n\n    // Configure the hammer instance.\n    if (isPlainObject(settings.dragHammerSettings)) {\n      hammer.set(settings.dragHammerSettings);\n    }\n\n    // Bind drag events.\n    hammer\n    .on('draginit dragstart dragmove', function (e) {\n\n      // Let's activate drag start predicate state.\n      if (startPredicateState === startPredicateInactive) {\n        startPredicateState = startPredicatePending;\n      }\n\n      // If predicate is pending try to resolve it.\n      if (startPredicateState === startPredicatePending) {\n        startPredicateResult = startPredicate(drag.getItem(), e);\n        if (startPredicateResult === true) {\n          startPredicateState = startPredicateResolved;\n          drag.onStart(e);\n        }\n        else if (startPredicateResult === false) {\n          startPredicateState = startPredicateRejected;\n        }\n      }\n\n      // Otherwise if predicate is resolved and drag is active, move the item.\n      else if (startPredicateState === startPredicateResolved && drag._data.isActive) {\n        drag.onMove(e);\n      }\n\n    })\n    .on('dragend dragcancel draginitup', function (e) {\n\n      // Check if the start predicate was resolved during drag.\n      var isResolved = startPredicateState === startPredicateResolved;\n\n      // Do final predicate check to allow user to unbind stuff for the current\n      // drag procedure within the predicate callback. The return value of this\n      // check will have no effect to the state of the predicate.\n      startPredicate(drag.getItem(), e);\n\n      // Reset start predicate state.\n      startPredicateState = startPredicateInactive;\n\n      // If predicate is resolved and dragging is active, call the end handler.\n      if (isResolved && drag._data.isActive) {\n        drag.onEnd(e);\n      }\n\n    });\n\n    // Prevent native link/image dragging for the item and it's ancestors.\n    element.addEventListener('dragstart', preventDefault, false);\n\n  }\n\n  /**\n   * ItemDrag - Public methods\n   * *************************\n   */\n\n  /**\n   * Default drag start predicate handler that handles anchor elements\n   * gracefully. The return value of this function defines if the drag is\n   * started, rejected or pending. When true is returned the dragging is started\n   * and when false is returned the dragging is rejected. If nothing is returned\n   * the predicate will be called again on the next drag movement.\n   *\n   * @public\n   * @memberof ItemDrag\n   * @param {Item} item\n   * @param {Object} event\n   * @param {Object} [options]\n   *   - An optional options object which can be used to pass the predicate\n   *     it's options manually. By default the predicate retrieves the options\n   *     from the grid's settings.\n   * @returns {Boolean}\n   */\n  ItemDrag.defaultStartPredicate = function (item, event, options) {\n\n    var element = item._element;\n    var predicate = item._drag._startPredicateData;\n    var config;\n    var isAnchor;\n    var href;\n    var target;\n\n    // Setup data if it is not set up yet.\n    if (!predicate) {\n      config = options || item._drag.getGrid()._settings.dragStartPredicate;\n      config = isPlainObject(config) ? config : {};\n      predicate = item._drag._startPredicateData = {\n        distance: Math.abs(config.distance) || 0,\n        delay: Math.max(config.delay, 0) || 0,\n        handle: typeof config.handle === 'string' ? config.handle : false\n      };\n    }\n\n    // Final event logic. At this stage return value does not matter anymore,\n    // the predicate is either resolved or it's not and there's nothing to do\n    // about it. Here we just reset data and if the item element is a link\n    // we follow it (if there has only been slight movement).\n    if (event.isFinal) {\n      isAnchor = element.tagName.toLowerCase() === 'a';\n      href = element.getAttribute('href');\n      target = element.getAttribute('target');\n      dragStartPredicateReset(item);\n      if (isAnchor && href && Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200) {\n        if (target && target !== '_self') {\n          global.open(href, target);\n        }\n        else {\n          global.location.href = href;\n        }\n      }\n      return;\n    }\n\n    // Find and store the handle element so we can check later on if the\n    // cursor is within the handle. If we have a handle selector let's find\n    // the corresponding element. Otherwise let's use the item element as the\n    // handle.\n    if (!predicate.handleElement) {\n      if (predicate.handle) {\n        predicate.handleElement = (event.changedPointers[0] || {}).target;\n        while (predicate.handleElement && !elementMatches(predicate.handleElement, predicate.handle)) {\n          predicate.handleElement = predicate.handleElement !== element ? predicate.handleElement.parentElement : null;\n        }\n        if (!predicate.handleElement) {\n          return false;\n        }\n      }\n      else {\n        predicate.handleElement = element;\n      }\n    }\n\n    // If delay is defined let's keep track of the latest event and initiate\n    // delay if it has not been done yet.\n    if (predicate.delay) {\n      predicate.event = event;\n      if (!predicate.delayTimer) {\n        predicate.delayTimer = global.setTimeout(function () {\n          predicate.delay = 0;\n          if (dragStartPredicateResolve(item, predicate.event)) {\n            item._drag._resolveStartPredicate(predicate.event);\n            dragStartPredicateReset(item);\n          }\n        }, predicate.delay);\n      }\n    }\n\n    return dragStartPredicateResolve(item, event);\n\n  };\n\n  /**\n   * Default drag sort predicate.\n   *\n   * @public\n   * @memberof ItemDrag\n   * @param {Item} item\n   * @param {Object} event\n   * @returns {(Boolean|DragSortCommand)}\n   *   - Returns false if no valid index was found. Otherwise returns drag sort\n   *     command.\n   */\n  ItemDrag.defaultSortPredicate = function (item) {\n\n    var drag = item._drag;\n    var dragData = drag._data;\n    var rootGrid = drag.getGrid();\n    var settings = rootGrid._settings;\n    var config = settings.dragSortPredicate || {};\n    var sortThreshold = config.threshold || 50;\n    var sortAction = config.action || 'move';\n    var itemRect = {\n      width: item._width,\n      height: item._height,\n      left: dragData.elementClientX,\n      top: dragData.elementClientY\n    };\n    var grid = getTargetGrid(item, rootGrid, itemRect, sortThreshold);\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = -1;\n    var matchIndex;\n    var hasValidTargets;\n    var target;\n    var score;\n    var i;\n\n    // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n    if (!grid) {\n      return false;\n    }\n\n    // If item is moved within it's originating grid adjust item's left and top\n    // props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n    if (grid === rootGrid) {\n      itemRect.left = dragData.gridX + item._margin.left;\n      itemRect.top = dragData.gridY + item._margin.top;\n    }\n    else {\n      gridOffsetLeft = grid._left + grid._border.left;\n      gridOffsetTop = grid._top + grid._border.top;\n    }\n\n    // Loop through the target grid items and try to find the best match.\n    for (i = 0; i < grid._items.length; i++) {\n\n      target = grid._items[i];\n\n      // If the target item is not active or the target item is the dragged item\n      // let's skip to the next item.\n      if (!target._isActive || target === item) {\n        continue;\n      }\n\n      // Mark the grid as having valid target items.\n      hasValidTargets = true;\n\n      // Calculate the target's overlap score with the dragged item.\n      score = getRectOverlapScore(itemRect, {\n        width: target._width,\n        height: target._height,\n        left: target._left + target._margin.left + gridOffsetLeft,\n        top: target._top + target._margin.top + gridOffsetTop\n      });\n\n      // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n\n    }\n\n    // If there is no valid match and the item is being moved into another grid.\n    if (matchScore < sortThreshold && item.getGrid() !== grid) {\n      matchIndex = hasValidTargets ? -1 : 0;\n      matchScore = Infinity;\n    }\n\n    // Check if the best match overlaps enough to justify a placement switch.\n    if (matchScore >= sortThreshold) {\n      return {\n        grid: grid,\n        index: matchIndex,\n        action: sortAction\n      };\n    }\n\n    return false;\n\n  };\n\n  /**\n   * ItemDrag - Public prototype methods\n   * ***********************************\n   */\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.destroy = function () {\n\n    var drag = this;\n\n    if (!drag._isDestroyed) {\n      drag.stop();\n      drag._hammer.destroy();\n      drag.getItem()._element.removeEventListener('dragstart', preventDefault, false);\n      drag._isDestroyed = true;\n    }\n\n    return drag;\n\n  };\n\n  /**\n   * Get Item instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {?Item}\n   */\n  ItemDrag.prototype.getItem = function () {\n\n    return itemInstances[this._itemId] || null;\n\n  };\n\n  /**\n   * Get Grid instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {?Grid}\n   */\n  ItemDrag.prototype.getGrid = function () {\n\n    return gridInstances[this._gridId] || null;\n\n  };\n\n  /**\n   * Setup/reset drag data.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.reset = function () {\n\n    var drag = this;\n    var dragData = drag._data;\n\n    // Is item being dragged?\n    dragData.isActive = false;\n\n    // The dragged item's container element.\n    dragData.container = null;\n\n    // The dragged item's containing block.\n    dragData.containingBlock = null;\n\n    // Hammer event data.\n    dragData.startEvent = null;\n    dragData.currentEvent = null;\n\n    // All the elements which need to be listened for scroll events during\n    // dragging.\n    dragData.scrollers = [];\n\n    // The current translateX/translateY position.\n    dragData.left = 0;\n    dragData.top = 0;\n\n    // Dragged element's current position within the grid.\n    dragData.gridX = 0;\n    dragData.gridY = 0;\n\n    // Dragged element's current offset from window's northwest corner. Does\n    // not account for element's margins.\n    dragData.elementClientX = 0;\n    dragData.elementClientY = 0;\n\n    // Offset difference between the dragged element's temporary drag\n    // container and it's original container.\n    dragData.containerDiffX = 0;\n    dragData.containerDiffY = 0;\n\n    return drag;\n\n  };\n\n  /**\n   * Bind drag scroll handlers to all scrollable ancestor elements of the\n   * dragged element and the drag container element.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.bindScrollListeners = function () {\n\n    var drag = this;\n    var gridContainer = drag.getGrid()._element;\n    var dragContainer = drag._data.container;\n    var scrollers = getScrollParents(drag.getItem()._element);\n    var i;\n\n    // If drag container is defined and it's not the same element as grid\n    // container then we need to add the grid container and it's scroll parents\n    // to the elements which are going to be listener for scroll events.\n    if (dragContainer !== gridContainer) {\n      scrollers = arrayUnique(scrollers.concat(gridContainer).concat(getScrollParents(gridContainer)));\n    }\n\n    // Bind scroll listeners.\n    for (i = 0; i < scrollers.length; i++) {\n      scrollers[i].addEventListener('scroll', drag._scrollListener);\n    }\n\n    // Save scrollers to drag data.\n    drag._data.scrollers = scrollers;\n\n    return drag;\n\n  };\n\n  /**\n   * Unbind currently bound drag scroll handlers from all scrollable ancestor\n   * elements of the dragged element and the drag container element.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.unbindScrollListeners = function () {\n\n    var drag = this;\n    var dragData = drag._data;\n    var scrollers = dragData.scrollers;\n    var i;\n\n    for (i = 0; i < scrollers.length; i++) {\n      scrollers[i].removeEventListener('scroll', drag._scrollListener);\n    }\n\n    dragData.scrollers = [];\n\n    return drag;\n\n  };\n\n  /**\n   * Check (during drag) if an item is overlapping other items and based on\n   * the configuration layout the items.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.checkOverlap = function () {\n\n    var drag = this;\n    var item = drag.getItem();\n    var result = drag._sortPredicate(item, drag._data.currentEvent);\n    var currentGrid;\n    var currentIndex;\n    var targetGrid;\n    var targetIndex;\n    var sortAction;\n    var isMigration;\n\n    // Let's make sure the result object has a valid index before going further.\n    if (!isPlainObject(result) || typeof result.index !== typeNumber) {\n      return drag;\n    }\n\n    currentGrid = item.getGrid();\n    targetGrid = result.grid || currentGrid;\n    isMigration = currentGrid !== targetGrid;\n    currentIndex = currentGrid._items.indexOf(item);\n    targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration);\n    sortAction = result.action === 'swap' ? 'swap' : 'move';\n\n    // If the item was moved within it's current grid.\n    if (!isMigration) {\n\n      // Make sure the target index is not the current index.\n      if (currentIndex !== targetIndex) {\n\n        // Do the sort.\n        (sortAction === 'swap' ? arraySwap : arrayMove)(currentGrid._items, currentIndex, targetIndex);\n\n        // Emit move event.\n        currentGrid._emit(evMove, {\n          item: item,\n          fromIndex: currentIndex,\n          toIndex: targetIndex,\n          action: sortAction\n        });\n\n        // Layout the grid.\n        currentGrid.layout();\n\n      }\n\n    }\n\n    // If the item was moved to another grid.\n    else {\n\n      // Emit beforeSend event.\n      currentGrid._emit(evBeforeSend, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Emit beforeReceive event.\n      targetGrid._emit(evBeforeReceive, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Update item's grid id reference.\n      item._gridId = targetGrid._id;\n\n      // Update drag instances's migrating indicator.\n      drag._isMigrating = item._gridId !== drag._gridId;\n\n      // Move item instance from current grid to target grid.\n      currentGrid._items.splice(currentIndex, 1);\n      insertItemsToArray(targetGrid._items, item, targetIndex);\n\n      // Set sort data as null, which is an indicator for the item comparison\n      // function that the sort data of this specific item should be fetched\n      // lazily.\n      item._sortData = null;\n\n      // Emit send event.\n      currentGrid._emit(evSend, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Emit receive event.\n      targetGrid._emit(evReceive, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n\n      // Layout both grids.\n      currentGrid.layout();\n      targetGrid.layout();\n\n    }\n\n    return drag;\n\n  };\n\n  /**\n   * If item is dragged into another grid, finish the migration process\n   * gracefully.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.finishMigration = function () {\n\n    var drag = this;\n    var item = drag.getItem();\n    var release = item._release;\n    var element = item._element;\n    var targetGrid = item.getGrid();\n    var targetGridElement = targetGrid._element;\n    var targetSettings = targetGrid._settings;\n    var targetContainer = targetSettings.dragContainer || targetGridElement;\n    var currentSettings = drag.getGrid()._settings;\n    var currentContainer = element.parentNode;\n    var translateX;\n    var translateY;\n    var offsetDiff;\n\n    // Destroy current drag. Note that we need to set the migrating flag to\n    // false first, because otherwise we create an infinite loop between this\n    // and the drag.stop() method.\n    drag._isMigrating = false;\n    drag.destroy();\n\n    // Destroy current animation handlers.\n    item._animate.destroy();\n    item._animateChild.destroy();\n\n    // Remove current classnames.\n    removeClass(element, currentSettings.itemClass);\n    removeClass(element, currentSettings.itemVisibleClass);\n    removeClass(element, currentSettings.itemHiddenClass);\n\n    // Add new classnames.\n    addClass(element, targetSettings.itemClass);\n    addClass(element, targetSettings.itemVisibleClass);\n\n    // Instantiate new animation controllers.\n    item._animate = new Grid.ItemAnimate(item, element);\n    item._animateChild = new Grid.ItemAnimate(item, item._child);\n\n    // Move the item inside the target container if it's different than the\n    // current container.\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n      translateX = getTranslateAsFloat(element, 'x') - offsetDiff.left;\n      translateY = getTranslateAsFloat(element, 'y') - offsetDiff.top;\n    }\n\n    // Update item's cached dimensions and sort data.\n    item._refreshDimensions()._refreshSortData();\n\n    // Calculate the offset difference between target's drag container (if any)\n    // and actual grid container element. We save it later for the release\n    // process.\n    offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n    release.containerDiffX = offsetDiff.left;\n    release.containerDiffY = offsetDiff.top;\n\n    // Recreate item's drag handler.\n    item._drag = targetSettings.dragEnabled ? new Grid.ItemDrag(item) : null;\n\n    // Adjust the position of the item element if it was moved from a container\n    // to another.\n    if (targetContainer !== currentContainer) {\n      setStyles(element, {transform: getTranslateString(translateX, translateY)});\n    }\n\n    // Update child element's styles to reflect the current visibility state.\n    item._child.removeAttribute('style');\n    targetGrid._itemShowHandler.start(item, true);\n\n    // Start the release.\n    release.start();\n\n    return drag;\n\n  };\n\n  /**\n   * cancel move/scroll event raf loop action.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.cancelRafLoop = function () {\n\n    var id = this.getItem()._id;\n\n    rafLoop.cancel(rafQueueScroll, id);\n    rafLoop.cancel(rafQueueMove, id);\n\n    return this;\n\n  };\n\n  /**\n   * Abort dragging and reset drag data.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.stop = function () {\n\n    var drag = this;\n    var dragData = drag._data;\n    var item = drag.getItem();\n    var element = item._element;\n    var grid = drag.getGrid();\n\n    if (!dragData.isActive) {\n      return drag;\n    }\n\n    // If the item is being dropped into another grid, finish it up and return\n    // immediately.\n    if (drag._isMigrating) {\n      return drag.finishMigration(dragData.currentEvent);\n    }\n\n    // Cancel raf loop actions.\n    drag.cancelRafLoop();\n\n    // Remove scroll listeners.\n    drag.unbindScrollListeners();\n\n    // Cancel overlap check.\n    drag._checkSortOverlap('cancel');\n\n    // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n      setStyles(element, {transform: getTranslateString(dragData.gridX, dragData.gridY)});\n    }\n\n    // Remove dragging class.\n    removeClass(element, grid._settings.itemDraggingClass);\n\n    // Reset drag data.\n    drag.reset();\n\n    return drag;\n\n  };\n\n  /**\n   * Drag start handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onStart = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n\n    // If item is not active, don't start the drag.\n    if (!item._isActive) {\n      return drag;\n    }\n\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var dragData = drag._data;\n    var release = item._release;\n    var migrate = item._migrate;\n    var gridContainer = grid._element;\n    var dragContainer = settings.dragContainer || gridContainer;\n    var containingBlock = getContainingBlock(dragContainer, true);\n    var offsetDiff = dragContainer !== gridContainer ? getOffsetDiff(containingBlock, gridContainer) : 0;\n    var currentLeft = getTranslateAsFloat(element, 'x');\n    var currentTop = getTranslateAsFloat(element, 'y');\n    var elementRect = element.getBoundingClientRect();\n\n    // Stop current positioning animation.\n    if (item.isPositioning()) {\n      item._stopLayout(true, {transform: getTranslateString(currentLeft, currentTop)});\n    }\n\n    // Stop current migration animation.\n    if (migrate.isActive) {\n      currentLeft -= migrate.containerDiffX;\n      currentTop -= migrate.containerDiffY;\n      migrate.stop(true, {transform: getTranslateString(currentLeft, currentTop)});\n    }\n\n    // If item is being released reset release data.\n    if (item.isReleasing()) {\n      release.reset();\n    }\n\n    // Setup drag data.\n    dragData.isActive = true;\n    dragData.startEvent = dragData.currentEvent = event;\n    dragData.container = dragContainer;\n    dragData.containingBlock = containingBlock;\n    dragData.elementClientX = elementRect.left;\n    dragData.elementClientY = elementRect.top;\n    dragData.left = dragData.gridX = currentLeft;\n    dragData.top = dragData.gridY = currentTop;\n\n    // Emit dragInit event.\n    grid._emit(evDragInit, item, event);\n\n    // If a specific drag container is set and it is different from the\n    // grid's container element we need to cast some extra spells.\n    if (dragContainer !== gridContainer) {\n\n      // Store the container offset diffs to drag data.\n      dragData.containerDiffX = offsetDiff.left;\n      dragData.containerDiffY = offsetDiff.top;\n\n      // If the dragged element is a child of the drag container all we need to\n      // do is setup the relative drag position data.\n      if (element.parentNode === dragContainer) {\n        dragData.gridX = currentLeft - dragData.containerDiffX;\n        dragData.gridY = currentTop - dragData.containerDiffY;\n      }\n\n      // Otherwise we need to append the element inside the correct container,\n      // setup the actual drag position data and adjust the element's translate\n      // values to account for the DOM position shift.\n      else {\n        dragData.left = currentLeft + dragData.containerDiffX;\n        dragData.top = currentTop + dragData.containerDiffY;\n        dragContainer.appendChild(element);\n        setStyles(element, {transform: getTranslateString(dragData.left, dragData.top)});\n      }\n\n    }\n\n    // Set drag class and bind scrollers.\n    addClass(element, settings.itemDraggingClass);\n    drag.bindScrollListeners();\n\n    // Emit dragStart event.\n    grid._emit(evDragStart, item, event);\n\n    return drag;\n\n  };\n\n  /**\n   * Drag move handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onMove = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      return drag.stop();\n    }\n\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var dragData = drag._data;\n    var axis = settings.dragAxis;\n    var xDiff = event.deltaX - dragData.currentEvent.deltaX;\n    var yDiff = event.deltaY - dragData.currentEvent.deltaY;\n\n    rafLoop.add(rafQueueMove, item._id, function () {\n\n      // Update current event.\n      dragData.currentEvent = event;\n\n      // Update horizontal position data.\n      if (axis !== 'y') {\n        dragData.left += xDiff;\n        dragData.gridX += xDiff;\n        dragData.elementClientX += xDiff;\n      }\n\n      // Update vertical position data.\n      if (axis !== 'x') {\n        dragData.top += yDiff;\n        dragData.gridY += yDiff;\n        dragData.elementClientY += yDiff;\n      }\n\n      // Overlap handling.\n      settings.dragSort && drag._checkSortOverlap();\n\n    }, function () {\n\n      // Update element's translateX/Y values.\n      setStyles(element, {transform: getTranslateString(dragData.left, dragData.top)});\n\n      // Emit dragMove event.\n      grid._emit(evDragMove, item, event);\n\n    });\n\n    return drag;\n\n  };\n\n  /**\n   * Drag scroll handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onScroll = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var axis = settings.dragAxis;\n    var dragData = drag._data;\n    var gridContainer = grid._element;\n    var elementRect;\n    var xDiff;\n    var yDiff;\n    var offsetDiff;\n\n    rafLoop.add(rafQueueScroll, item._id, function () {\n\n      // Calculate element's rect and x/y diff.\n      elementRect = element.getBoundingClientRect();\n      xDiff = dragData.elementClientX - elementRect.left;\n      yDiff = dragData.elementClientY - elementRect.top;\n\n      // Update container diff.\n      if (dragData.container !== gridContainer) {\n        offsetDiff = getOffsetDiff(dragData.containingBlock, gridContainer);\n        dragData.containerDiffX = offsetDiff.left;\n        dragData.containerDiffY = offsetDiff.top;\n      }\n\n      // Update horizontal position data.\n      if (axis !== 'y') {\n        dragData.left += xDiff;\n        dragData.gridX = dragData.left - dragData.containerDiffX;\n      }\n\n      // Update vertical position data.\n      if (axis !== 'x') {\n        dragData.top += yDiff;\n        dragData.gridY = dragData.top - dragData.containerDiffY;\n      }\n\n      // Overlap handling.\n      settings.dragSort && drag._checkSortOverlap();\n\n    }, function () {\n\n      // Update element's translateX/Y values.\n      setStyles(element, {transform: getTranslateString(dragData.left, dragData.top)});\n\n      // Emit dragScroll event.\n      grid._emit(evDragScroll, item, event);\n\n    });\n\n    return drag;\n\n  };\n\n  /**\n   * Drag end handler.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @param {Object} event\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.onEnd = function (event) {\n\n    var drag = this;\n    var item = drag.getItem();\n    var element = item._element;\n    var grid = drag.getGrid();\n    var settings = grid._settings;\n    var dragData = drag._data;\n    var release = item._release;\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      return drag.stop();\n    }\n\n    // Cancel raf loop actions.\n    drag.cancelRafLoop();\n\n    // Finish currently queued overlap check.\n    settings.dragSort && drag._checkSortOverlap('finish');\n\n    // Remove scroll listeners.\n    drag.unbindScrollListeners();\n\n    // Setup release data.\n    release.containerDiffX = dragData.containerDiffX;\n    release.containerDiffY = dragData.containerDiffY;\n\n    // Reset drag data.\n    drag.reset();\n\n    // Remove drag classname from element.\n    removeClass(element, settings.itemDraggingClass);\n\n    // Emit dragEnd event.\n    grid._emit(evDragEnd, item, event);\n\n    // Finish up the migration process or start the release process.\n    drag._isMigrating ? drag.finishMigration() : release.start();\n\n    return drag;\n\n  };\n\n  /**\n   * Helpers - Generic\n   * *****************\n   */\n\n  /**\n   * Normalize array index. Basically this function makes sure that the provided\n   * array index is within the bounds of the provided array and also transforms\n   * negative index to the matching positive index.\n   *\n   * @private\n   * @param {Array} array\n   * @param {Number} index\n   * @param {Boolean} isMigration\n   */\n  function normalizeArrayIndex(array, index, isMigration) {\n\n    var length = array.length;\n    var maxIndex = Math.max(0, isMigration ? length : length - 1);\n\n    return index > maxIndex ? maxIndex :\n      index < 0 ? Math.max(maxIndex + index + 1, 0) :\n      index;\n\n  }\n\n  /**\n   * Swap array items.\n   *\n   * @private\n   * @param {Array} array\n   * @param {Number} index\n   *   - Index (positive or negative) of the item that will be swapped.\n   * @param {Number} withIndex\n   *   - Index (positive or negative) of the other item that will be swapped.\n   */\n  function arraySwap(array, index, withIndex) {\n\n    // Make sure the array has two or more items.\n    if (array.length < 2) {\n      return;\n    }\n\n    // Normalize the indices.\n    var indexA = normalizeArrayIndex(array, index);\n    var indexB = normalizeArrayIndex(array, withIndex);\n    var temp;\n\n    // Swap the items.\n    if (indexA !== indexB) {\n      temp = array[indexA];\n      array[indexA] = array[indexB];\n      array[indexB] = temp;\n    }\n\n  }\n\n  /**\n   * Move array item to another index.\n   *\n   * @private\n   * @param {Array} array\n   * @param {Number} fromIndex\n   *   - Index (positive or negative) of the item that will be moved.\n   * @param {Number} toIndex\n   *   - Index (positive or negative) where the item should be moved to.\n   */\n  function arrayMove(array, fromIndex, toIndex) {\n\n    // Make sure the array has two or more items.\n    if (array.length < 2) {\n      return;\n    }\n\n    // Normalize the indices.\n    var from = normalizeArrayIndex(array, fromIndex);\n    var to = normalizeArrayIndex(array, toIndex);\n\n    // Add target item to the new position.\n    if (from !== to) {\n      array.splice(to, 0, array.splice(from, 1)[0]);\n    }\n\n  }\n\n  /**\n   * Returns a new duplicate free version of the provided array.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Array}\n   */\n  function arrayUnique(array) {\n\n    var ret = [];\n    var len = array.length;\n    var i;\n\n    if (len) {\n      ret[0] = array[0];\n      for (i = 1; i < len; i++) {\n        if (ret.indexOf(array[i]) < 0) {\n          ret.push(array[i]);\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Check if a value is a node list\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isNodeList(val) {\n\n    var type = Object.prototype.toString.call(val);\n    return type === '[object HTMLCollection]' || type === '[object NodeList]';\n\n  }\n\n  /**\n   * Merge two objects recursively (deep merge). The source object's properties\n   * are merged to the target object.\n   *\n   * @private\n   * @param {Object} target\n   *   - The target object.\n   * @param {Object} source\n   *   - The source object.\n   * @returns {Object} Returns the target object.\n   */\n  function mergeObjects(target, source) {\n\n    // Loop through the surce object's props.\n    Object.keys(source).forEach(function (propName) {\n\n      var isObject = isPlainObject(source[propName]);\n\n      // If target and source values are both objects, merge the objects and\n      // assign the merged value to the target property.\n      if (isPlainObject(target[propName]) && isObject) {\n        target[propName] = mergeObjects({}, target[propName]);\n        target[propName] = mergeObjects(target[propName], source[propName]);\n      }\n\n      // Otherwise set the source object's value to target object and make sure\n      // that object and array values are cloned and directly assigned.\n      else {\n        target[propName] = isObject ? mergeObjects({}, source[propName]) :\n          Array.isArray(source[propName]) ? source[propName].concat() :\n          source[propName];\n      }\n\n    });\n\n    return target;\n\n  }\n\n  /**\n   * Insert an item or an array of items to array to a specified index. Mutates\n   * the array. The index can be negative in which case the items will be added\n   * to the end of the array.\n   *\n   * @private\n   * @param {Array} array\n   * @param {*} items\n   * @param {Number} [index=-1]\n   */\n  function insertItemsToArray(array, items, index) {\n\n    var targetIndex = typeof index === typeNumber ? index : -1;\n    array.splice.apply(array, [targetIndex < 0 ? array.length - targetIndex + 1 : targetIndex, 0].concat(items));\n\n  }\n\n  /**\n   * Returns a function, that, as long as it continues to be invoked, will not\n   * be triggered. The function will be called after it stops being called for\n   * N milliseconds. The returned function accepts one argument which, when\n   * being \"finish\", calls the debounced function immediately if it is currently\n   * waiting to be called, and when being \"cancel\" cancels the currently queued\n   * function call.\n   *\n   * @private\n   * @param {Function} fn\n   * @param {Number} wait\n   * @returns {Function}\n   */\n  function debounce(fn, wait) {\n\n    var timeout;\n    var actionCancel = 'cancel';\n    var actionFinish = 'finish';\n\n    return wait > 0 ? function (action) {\n\n      if (timeout !== undefined) {\n        timeout = global.clearTimeout(timeout);\n        if (action === actionFinish) {\n          fn();\n        }\n      }\n\n      if (action !== actionCancel && action !== actionFinish) {\n        timeout = global.setTimeout(function () {\n          timeout = undefined;\n          fn();\n        }, wait);\n      }\n\n    } : function (action) {\n\n      if (action !== actionCancel) {\n        fn();\n      }\n\n    };\n\n  }\n\n  /**\n   * Returns a raf loop queue system that allows pushing callbacks to either\n   * the read queue or the write queue.\n   *\n   * @private\n   * @returns {Object}\n   */\n  function createRafLoop() {\n\n    var nextTick = null;\n    var queue = [];\n    var map = {};\n    var raf = (global.requestAnimationFrame\n      || global.webkitRequestAnimationFrame\n      || global.mozRequestAnimationFrame\n      || global.msRequestAnimationFrame\n      || function (cb) {\n        return global.setTimeout(cb, 16);\n      }\n    ).bind(global);\n\n    function add(type, id, readCallback, writeCallback) {\n\n      // First, let's check if an item has been added to the queues with the\n      // same id and remove it.\n      var currentIndex = queue.indexOf(type + id);\n      if (currentIndex > -1) {\n        queue.splice(currentIndex, 1);\n      }\n\n      // Add all move/scroll event callbacks to the beginning of the queue\n      // and other callbacks to the end of the queue.\n      type === rafQueueMove || type === rafQueueScroll ? queue.unshift(type + id) : queue.push(type + id);\n      map[type + id] = [readCallback, writeCallback];\n\n      // Finally, let's kickstart the next tick if it is not running yet.\n      !nextTick && (nextTick = raf(flush));\n\n    }\n\n    function cancel(type, id) {\n\n      // Let's check if an item has been added to the queue with the id and\n      // if so -> remove it.\n      var currentIndex = queue.indexOf(type + id);\n      if (currentIndex > -1) {\n        queue.splice(currentIndex, 1);\n        map[type + id] = undefined;\n      }\n\n    }\n\n    function flush() {\n\n      var maxBatchSize = +Grid._maxRafBatchSize || 100;\n      var batch = queue.splice(0, Math.min(maxBatchSize, queue.length));\n      var batchMap = {};\n      var i;\n\n      // Reset ticker.\n      nextTick = null;\n\n      // Create batch map and clear map items.\n      for (i = 0; i < batch.length; i++) {\n        batchMap[batch[i]] = map[batch[i]];\n        map[batch[i]] = undefined;\n      }\n\n      // Process read callbacks.\n      for (i = 0; i < batch.length; i++) {\n        batchMap[batch[i]][0]();\n      }\n\n      // Process write callbacks.\n      for (i = 0; i < batch.length; i++) {\n        batchMap[batch[i]][1]();\n      }\n\n      // Restart the ticker if needed.\n      if (!nextTick && queue.length) {\n        nextTick = raf(flush);\n      }\n\n    }\n\n    return {\n      add: add,\n      cancel: cancel\n    };\n\n  }\n\n  /**\n   * Helpers - DOM utils\n   * *******************\n   */\n\n  /**\n   * Transforms a camel case style property to kebab case style property.\n   *\n   * @private\n   * @param {String} string\n   * @returns {String}\n   */\n  function getStyleName(string) {\n\n    return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(element, style) {\n\n    return global.getComputedStyle(element, null).getPropertyValue(style === 'transform' ? transform.styleName || style : style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {HTMLElement} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return parseFloat(getStyle(el, style)) || 0;\n\n  }\n\n  /**\n   * Returns the element's computed translateX/Y value as a float. Assumes that\n   * the translate value is defined as pixels.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} axis\n   *   - \"x\" or \"y\".\n   * @returns {Number}\n   */\n  function getTranslateAsFloat(element, axis) {\n\n    return parseFloat((getStyle(element, 'transform') || '').replace('matrix(', '').split(',')[axis === 'x' ? 4 : 5]) || 0;\n\n  }\n\n  /**\n   * Transform translateX and translateY value into CSS transform style\n   * property's value.\n   *\n   * @private\n   * @param {Number} translateX\n   * @param {Number} translateY\n   * @returns {String}\n   */\n  function getTranslateString(translateX, translateY) {\n\n    return 'translateX(' + translateX + 'px) translateY(' + translateY + 'px)';\n\n  }\n\n  /**\n   * Get current values of the provided styles definition object.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {Object}\n   */\n  function getCurrentStyles(element, styles) {\n\n    var current = {};\n    var keys = Object.keys(styles);\n    var i;\n\n    for (i = 0; i < keys.length; i++) {\n      current[keys[i]] = getStyle(element, getStyleName(keys[i]));\n    }\n\n    return current;\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   */\n  function setStyles(element, styles) {\n\n    var props = Object.keys(styles);\n    var i;\n\n    for (i = 0; i < props.length; i++) {\n      element.style[props[i] === 'transform' && transform ? transform.propName : props[i]] = styles[props[i]];\n    }\n\n  }\n\n  /**\n   * Add class to an element.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} className\n   */\n  function addClass(element, className) {\n\n    if (element.classList) {\n      element.classList.add(className);\n    }\n    else if (!elementMatches(element, '.' + className)) {\n      element.className += ' ' + className;\n    }\n\n  }\n\n  /**\n   * Remove class name from an element.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {String} className\n   */\n  function removeClass(element, className) {\n\n    if (element.classList) {\n      element.classList.remove(className);\n    }\n    else if (elementMatches(element, '.' + className)) {\n      element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();\n    }\n\n  }\n\n  /**\n   * Convert nodeList to array.\n   *\n   * @private\n   * @param {NodeList} nodeList\n   * @returns {HTMLElement[]}\n   */\n  function nodeListToArray(nodeList) {\n\n    return [].slice.call(nodeList);\n\n  }\n\n  /**\n   * Checks the supported element.matches() method and returns a function that\n   * can be used to call the supported method.\n   *\n   * @private\n   * @returns {Function}\n   */\n  function getSupportedElementMatches() {\n\n    var p = Element.prototype;\n    var fn = p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;\n\n    return function (el, selector) {\n      return fn.call(el, selector);\n    };\n\n  }\n\n  /**\n   * Returns the supported style property's prefix, property name and style name\n   * or null if the style property is not supported. This is used for getting\n   * the supported transform.\n   *\n   * @private\n   * @param {String} style\n   * @returns {?Object}\n   */\n  function getSupportedStyle(style) {\n\n    var styleCap = style.charAt(0).toUpperCase() + style.slice(1);\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    var prefix;\n    var propName;\n    var i;\n\n    for (i = 0; i < prefixes.length; i++) {\n      prefix = prefixes[i];\n      propName = prefix ? prefix + styleCap : style;\n      if (docElem.style[propName] !== undefined) {\n        prefix = prefix.toLowerCase();\n        return {\n          prefix: prefix,\n          propName: propName,\n          styleName: prefix ? '-' + prefix + '-' + style : style\n        };\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Calculate the offset difference two elements.\n   *\n   * @private\n   * @param {HTMLElement} elemA\n   * @param {HTMLElement} elemB\n   * @param {Boolean} [compareContainingBlocks=false]\n   *   - When this is set to true the containing blocks of the provided elements\n   *     will be used for calculating the difference. Otherwise the provided\n   *     elements will be compared directly.\n   * @returns {Object}\n   */\n  function getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n\n    if (elemA === elemB) {\n      return {\n        left: 0,\n        top: 0\n      };\n    }\n\n    if (compareContainingBlocks) {\n      elemA = getContainingBlock(elemA, true);\n      elemB = getContainingBlock(elemB, true);\n    }\n\n    var aOffset = getOffset(elemA, true);\n    var bOffset = getOffset(elemB, true);\n\n    return {\n      left: bOffset.left - aOffset.left,\n      top: bOffset.top - aOffset.top\n    };\n\n  }\n\n  /**\n   * Returns the element's document offset, which in practice means the vertical\n   * and horizontal distance between the element's northwest corner and the\n   * document's northwest corner.\n   *\n   * @private\n   * @param {(Document|Element|Window)} element\n   * @param {Boolean} [excludeElementBorders=false]\n   * @returns {Offset}\n   */\n  function getOffset(element, excludeElementBorders) {\n\n    var rect;\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (element === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = global.pageXOffset || 0;\n    ret.top = global.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (element.self === global.self) {\n      return ret;\n    }\n\n    // Add element's client rects to the offsets.\n    rect = element.getBoundingClientRect();\n    ret.left += rect.left;\n    ret.top += rect.top;\n\n    // Exclude element's borders from the offset if needed.\n    if (excludeElementBorders) {\n      ret.left += getStyleAsFloat(element, 'border-left-width');\n      ret.top += getStyleAsFloat(element, 'border-top-width');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an aabsolute positioned element's containing block, which is\n   * considered to be the closest ancestor element that the target element's\n   * positioning is relative to. Disclaimer: this only works as intended for\n   * abolute positioned elements.\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @param {Boolean} [isParent=false]\n   *   - When this is set to true the containing block checking is started from\n   *     the provided element. Otherwise the checking is started from the\n   *     provided element's parent element.\n   * @returns {(Document|Element)}\n   */\n  function getContainingBlock(element, isParent) {\n\n    // As long as the containing block is an element, static and not\n    // transformed, try to get the element's parent element and fallback to\n    // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n    var ret = (isParent ? element : element.parentElement) || doc;\n    while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n      ret = ret.parentElement || doc;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Get element's scroll parents.\n   *\n   * Borrowed from jQuery UI library (and heavily modified):\n   * https://github.com/jquery/jquery-ui/blob/63448148a217da7e64c04b21a04982f0d6\n   * 4aabaa/ui/scroll-parent.js\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @returns {HTMLElement[]}\n   */\n  function getScrollParents(element) {\n\n    var ret = [];\n    var overflowRegex = /(auto|scroll)/;\n    var parent = element.parentNode;\n\n    // If transformed elements leak fixed elements.\n    if (transformLeaksFixed) {\n\n      // If the element is fixed it can not have any scroll parents.\n      if (getStyle(element, 'position') === 'fixed') {\n        return ret;\n      }\n\n      // Find scroll parents.\n      while (parent && parent !== doc && parent !== docElem) {\n        if (overflowRegex.test(getStyle(parent, 'overflow') + getStyle(parent, 'overflow-y') + getStyle(parent, 'overflow-x'))) {\n          ret.push(parent);\n        }\n        parent = getStyle(parent, 'position') === 'fixed' ? null : parent.parentNode;\n      }\n\n      // If parent is not fixed element, add window object as the last scroll\n      // parent.\n      parent !== null && ret.push(global);\n\n    }\n    // If fixed elements behave as defined in the W3C specification.\n    else {\n\n      // Find scroll parents.\n      while (parent && parent !== doc) {\n\n        // If the currently looped element is fixed ignore all parents that are\n        // not transformed.\n        if (getStyle(element, 'position') === 'fixed' && !isTransformed(parent)) {\n          parent = parent.parentNode;\n          continue;\n        }\n\n        // Add the parent element to return items if it is scrollable.\n        if (overflowRegex.test(getStyle(parent, 'overflow') + getStyle(parent, 'overflow-y') + getStyle(parent, 'overflow-x'))) {\n          ret.push(parent);\n        }\n\n        // Update element and parent references.\n        element = parent;\n        parent = parent.parentNode;\n\n      }\n\n      // If the last item is the root element, replace it with the global\n      // object (window). The root element scroll is propagated to the window.\n      if (ret[ret.length - 1] === docElem) {\n        ret[ret.length - 1] = global;\n      }\n\n      // Otherwise add global object (window) as the last scroll parent.\n      else {\n        ret.push(global);\n      }\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox). So we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * Borrowed from Mezr (v0.6.1):\n   * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L607\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!transform) {\n      return true;\n    }\n\n    var elems = [0, 1].map(function (elem, isInner) {\n      elem = doc.createElement('div');\n      setStyles(elem, {\n        position: isInner ? 'fixed' : 'absolute',\n        display: 'block',\n        visibility: 'hidden',\n        left: isInner ? '0px' : '1px',\n        transform: 'none'\n      });\n      return elem;\n    });\n    var outer = body.appendChild(elems[0]);\n    var inner = outer.appendChild(elems[1]);\n    var left = inner.getBoundingClientRect().left;\n    setStyles(outer, {transform: 'scale(1)'});\n    var isLeaking = left === inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return isLeaking;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * Borrowed from Mezr (v0.6.1):\n   * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n   *\n   * @private\n   * @param {HTMLElement} element\n   * @returns {Boolean}\n   */\n  function isTransformed(element) {\n\n    var transform = getStyle(element, 'transform');\n    var display = getStyle(element, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Calculate how many percent the intersection area of two rectangles is from\n   * the maximum potential intersection area between the rectangles.\n   *\n   * @private\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   *   - A number between 0-100.\n   */\n  function getRectOverlapScore(a, b) {\n\n    // Return 0 immediately if the rectangles do not overlap.\n    if (!muuriLayout.doRectsOverlap(a, b)) {\n      return 0;\n    }\n\n    // Calculate intersection area's width, height, max height and max width.\n    var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n    var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n    var maxWidth = Math.min(a.width, b.width);\n    var maxHeight = Math.min(a.height, b.height);\n\n    return (width * height) / (maxWidth * maxHeight) * 100;\n\n  }\n\n  /**\n   * Helpers - Item sort utilities\n   * *****************************\n   */\n\n  /**\n   * Helper for the sort method to generate mapped version of the items array\n   * than contains reference to the item indices.\n   *\n   * @private\n   * @param {Item[]} items\n   * @returns {Object}\n   */\n  function getItemIndexMap(items) {\n\n    var ret = {};\n    var i;\n\n    for (i = 0; i < items.length; i++) {\n      ret[items[i]._id] = i;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Helper for the sort method to compare the indices of the items to enforce\n   * stable sort.\n   *\n   * @private\n   * @param {Item} itemA\n   * @param {Item} itemB\n   * @param {Boolean} isDescending\n   * @param {Object} indexMap\n   * @returns {Number}\n   */\n  function compareItemIndices(itemA, itemB, isDescending, indexMap) {\n\n    var indexA = indexMap[itemA._id];\n    var indexB = indexMap[itemB._id];\n    return isDescending ? indexB - indexA : indexA - indexB;\n\n  }\n\n  /**\n   * Helper for the sort method to compare the items based on the provided\n   * attributes.\n   *\n   * @private\n   * @param {Item} itemA\n   * @param {Item} itemB\n   * @param {Boolean} isDescending\n   * @param {Object} criterias\n   * @returns {Number}\n   */\n  function compareItems(itemA, itemB, isDescending, criterias) {\n\n    var ret = 0;\n    var criteriaName;\n    var criteriaOrder;\n    var valA;\n    var valB;\n    var i;\n\n    // Loop through the list of sort criterias.\n    for (i = 0; i < criterias.length; i++) {\n\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = criterias[i][0];\n      criteriaOrder = criterias[i][1];\n\n      // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n      valA = (itemA._sortData ? itemA : itemA._refreshSortData())._sortData[criteriaName];\n      valB = (itemB._sortData ? itemB : itemB._refreshSortData())._sortData[criteriaName];\n\n      // Sort the items in descending order if defined so explicitly.\n      if (criteriaOrder === 'desc' || (!criteriaOrder && isDescending)) {\n        ret = valB < valA ? -1 : valB > valA ? 1 : 0;\n      }\n\n      // Otherwise sort items in ascending order.\n      else {\n        ret = valA < valB ? -1 : valA > valB ? 1 : 0;\n      }\n\n      // If we have -1 or 1 as the return value, let's return it immediately.\n      if (ret !== 0) {\n        return ret;\n      }\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Reorder an array of items based on another array of items.\n   *\n   * @private\n   * @param {Item[]} items\n   * @param {Item[]} refItems\n   * @returns {Item[]}\n   */\n  function sortItemsByReference(items, refItems) {\n\n    var newItems = [];\n    var currentItems = items.concat();\n    var item;\n    var currentIndex;\n    var i;\n\n    for (i = 0; i < refItems.length; i++) {\n      item = refItems[i];\n      currentIndex = currentItems.indexOf(item);\n      if (currentIndex > -1) {\n        newItems.push(item);\n        currentItems.splice(currentIndex, 1);\n      }\n    }\n\n    items.splice.apply(items, [0, items.length].concat(newItems).concat(currentItems));\n\n    return items;\n\n  }\n\n  /**\n   * Check if a point (coordinate) is within a rectangle.\n   *\n   * @private\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Rectangle} rect\n   * @return {Boolean}\n   */\n  function isPointWithinRect(x, y, rect) {\n\n    return rect.width\n      && rect.height\n      && x >= rect.left\n      && x < (rect.left + rect.width)\n      && y >= rect.top\n      && y < (rect.top + rect.height);\n\n  }\n\n  /**\n   * Helpers - Muuri\n   * ***************\n   */\n\n  /**\n   * Show or hide Grid instance's items.\n   *\n   * @private\n   * @param {Grid} inst\n   * @param {String} method\n   *   - \"show\" or \"hide\".\n   * @param {(GridMultiItemQuery|GridItemState)} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {(ShowCallback|HideCallback)} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  function gridShowHideHandler(inst, method, items, options) {\n\n    var targetItems = inst.getItems(items);\n    var opts = options || {};\n    var isInstant = opts.instant === true;\n    var callback = opts.onFinish;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var counter = targetItems.length;\n    var isShow = method === 'show';\n    var startEvent = isShow ? evShowStart : evHideStart;\n    var endEvent = isShow ? evShowEnd : evHideEnd;\n    var needsLayout = false;\n    var completedItems = [];\n    var hiddenItems = [];\n    var item;\n    var i;\n\n    // If there are no items call the callback, but don't emit any events.\n    if (!counter) {\n      if (typeof callback === typeFunction) {\n        callback(targetItems);\n      }\n    }\n\n    // Otherwise if we have some items let's dig in.\n    else {\n\n      // Emit showStart/hideStart event.\n      inst._emit(startEvent, targetItems.concat());\n\n      // Show/hide items.\n      for (i = 0; i < targetItems.length; i++) {\n\n        item = targetItems[i];\n\n        // If inactive item is shown or active item is hidden we need to do\n        // layout.\n        if ((isShow && !item._isActive) || (!isShow && item._isActive)) {\n          needsLayout = true;\n        }\n\n        // If inactive item is shown we also need to do some special hackery to\n        // make the item not animate it's next positioning (layout).\n        if (isShow && !item._isActive) {\n          item._skipNextLayoutAnimation = true;\n        }\n\n        // If the a hidden item is being shown we need to refresh the item's\n        // dimensions.\n        isShow && item._isHidden && hiddenItems.push(item);\n\n        // Show/hide the item.\n        item['_' + method](isInstant, function (interrupted, item) {\n\n          // If the current item's animation was not interrupted add it to the\n          // completedItems array.\n          if (!interrupted) {\n            completedItems.push(item);\n          }\n\n          // If all items have finished their animations call the callback\n          // and emit showEnd/hideEnd event.\n          if (--counter < 1) {\n            if (typeof callback === typeFunction) {\n              callback(completedItems.concat());\n            }\n            inst._emit(endEvent, completedItems.concat());\n          }\n\n        });\n\n      }\n\n      // Refresh hidden items.\n      hiddenItems.length && inst.refreshItems(hiddenItems);\n\n      // Layout if needed.\n      if (needsLayout && layout) {\n        inst.layout(layout === 'instant', typeof layout === typeFunction ? layout : undefined);\n      }\n\n    }\n\n    return inst;\n\n  }\n\n  /**\n   * Returns an object which contains start and stop methods for item's\n   * show/hide process.\n   *\n   * @param {String} type\n   * @param {Object} settings\n   * @returns {Object}\n   */\n  function getItemVisibilityHandler(type, settings) {\n\n    var isShow = type === 'show';\n    var duration = parseInt(isShow ? settings.showDuration : settings.hideDuration) || 0;\n    var easing = (isShow ? settings.showEasing : settings.hideEasing) || 'ease';\n    var styles = isShow ? settings.visibleStyles : settings.hiddenStyles;\n    var isEnabled = duration > 0;\n    var currentStyles;\n\n    styles = isPlainObject(styles) ? styles : null;\n\n    return {\n      start: function (item, instant, onFinish) {\n        if (!styles) {\n          onFinish && onFinish();\n        }\n        else {\n          rafLoop.cancel(rafQueueVisibility, item._id);\n          if (!isEnabled || instant) {\n            if (item._animateChild.isAnimating()) {\n              item._animateChild.stop(styles);\n            }\n            else {\n              setStyles(item._child, styles);\n            }\n            onFinish && onFinish();\n          }\n          else {\n            rafLoop.add(rafQueueVisibility, item._id, function () {\n              currentStyles = getCurrentStyles(item._child, styles);\n            }, function () {\n              item._animateChild.start(currentStyles, styles, {\n                duration: duration,\n                easing: easing,\n                onFinish: onFinish\n              });\n            });\n          }\n        }\n      },\n      stop: function (item, targetStyles) {\n        rafLoop.cancel(rafQueueVisibility, item._id);\n        item._animateChild.stop(targetStyles);\n      }\n    };\n\n  }\n\n  /**\n   * Get target grid for the default drag sort predicate.\n   *\n   * @private\n   * @param {Item} item\n   * @param {Grid} rootGrid\n   * @param {Rectangle} itemRect\n   * @param {Number} threshold\n   * @returns {?Grid}\n   */\n  function getTargetGrid(item, rootGrid, itemRect, threshold) {\n\n    var ret = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var grids = dragSort === true ? [rootGrid] : dragSort.call(rootGrid, item);\n    var bestScore = -1;\n    var gridScore;\n    var grid;\n    var i;\n\n    // Return immediately if there are no grids.\n    if (!Array.isArray(grids)) {\n      return ret;\n    }\n\n    // Loop through the grids and get the best match.\n    for (i = 0; i < grids.length; i++) {\n\n      grid = grids[i];\n\n      // Filter out all destroyed grids.\n      if (grid._isDestroyed) {\n        continue;\n      }\n\n      // We need to update the grid's offset since it may have changed during\n      // scrolling. This could be left as problem for the userland, but it's\n      // much nicer this way. One less hack for the user to worry about =)\n      grid._refreshDimensions();\n\n      // Check how much dragged element overlaps the container element.\n      gridScore = getRectOverlapScore(itemRect, {\n        width: grid._width,\n        height: grid._height,\n        left: grid._left,\n        top: grid._top\n      });\n\n      // Check if this grid is the best match so far.\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        ret = grid;\n      }\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Process item's callback queue.\n   *\n   * @private\n   * @param {Function[]} queue\n   * @param {Boolean} interrupted\n   * @param {Item} instance\n   */\n  function processQueue(queue, interrupted, instance) {\n\n    var callbacks = queue.splice(0, queue.length);\n    var i;\n\n    for (i = 0; i < callbacks.length; i++) {\n      callbacks[i](interrupted, instance);\n    }\n\n  }\n\n  /**\n   * Check if item is in specific state.\n   *\n   * @private\n   * @param {Item} item\n   * @param {GridItemState} state\n   *  - Accepted values are: \"active\", \"inactive\", \"visible\", \"hidden\",\n   *    \"showing\", \"hiding\", \"positioning\", \"dragging\", \"releasing\" and\n   *    \"migrating\".\n   * @returns {Boolean}\n   */\n  function isItemInState(item, state) {\n\n    var methodName;\n\n    if (state === 'inactive') {\n      return !item.isActive();\n    }\n\n    if (state === 'hidden') {\n      return !item.isVisible();\n    }\n\n    methodName = 'is' + state.charAt(0).toUpperCase() + state.slice(1);\n\n    return typeof item[methodName] === typeFunction ? item[methodName]() : false;\n\n  }\n\n  /**\n   * Prevent default.\n   *\n   * @private\n   * @param {Object} e\n   */\n  function preventDefault(e) {\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n  }\n\n  /**\n   * Merge default settings with user settings. The returned object is a new\n   * object with merged values. The merging is a deep merge meaning that all\n   * objects and arrays within the provided settings objects will be also merged\n   * so that modifying the values of the settings object will have no effect on\n   * the returned object.\n   *\n   * @private\n   * @param {Object} defaultSettings\n   * @param {Object} [userSettings]\n   * @returns {Object} Returns a new object.\n   */\n  function mergeSettings(defaultSettings, userSettings) {\n\n    // Create a fresh copy of default settings.\n    var ret = mergeObjects({}, defaultSettings);\n\n    // Merge user settings to default settings.\n    ret = userSettings ? mergeObjects(ret, userSettings) : ret;\n\n    // Handle visible/hidden styles manually so that the whole object is\n    // overriden instead of the props.\n    ret.visibleStyles = (userSettings || {}).visibleStyles || (defaultSettings || {}).visibleStyles;\n    ret.hiddenStyles = (userSettings || {}).hiddenStyles || (defaultSettings || {}).hiddenStyles;\n\n    return ret;\n\n  }\n\n  /**\n   * Resolver for default drag start predicate function.\n   *\n   * @private\n   * @param {Item} item\n   * @param {Object} event\n   * @returns {Boolean}\n   */\n  function dragStartPredicateResolve(item, event) {\n\n    var predicate = item._drag._startPredicateData;\n    var pointer = event.changedPointers[0];\n    var pageX = pointer && pointer.pageX || 0;\n    var pageY = pointer && pointer.pageY || 0;\n    var handleRect;\n\n    // If the moved distance is smaller than the threshold distance or there is\n    // some delay left, ignore this predicate cycle.\n    if (event.distance < predicate.distance || predicate.delay) {\n      return;\n    }\n\n    // Get handle rect.\n    handleRect = predicate.handleElement.getBoundingClientRect();\n\n    // Reset predicate data.\n    dragStartPredicateReset(item);\n\n    // If the cursor is still within the handle let's start the drag.\n    return isPointWithinRect(pageX, pageY, {\n      width: handleRect.width,\n      height: handleRect.height,\n      left: handleRect.left + (global.pageXOffset || 0),\n      top: handleRect.top + (global.pageYOffset || 0)\n    });\n\n  }\n\n  /**\n   * Reset for default drag start predicate function.\n   *\n   * @private\n   * @param {Item} item\n   */\n  function dragStartPredicateReset(item) {\n\n    var predicate = item._drag._startPredicateData;\n\n    if (predicate) {\n      if (predicate.delayTimer) {\n        predicate.delayTimer = global.clearTimeout(predicate.delayTimer);\n      }\n      item._drag._startPredicateData = null;\n    }\n\n  }\n\n  /**\n   * Default layout algorithm\n   * ************************\n   */\n\n  /*!\n    * muuriLayout v0.5.4\n    * Copyright (c) 2016 Niklas Rm <inramo@gmail.com>\n    * Released under the MIT license\n    */\n\n  /**\n   * The default Muuri layout algorithm. Based on MAXRECTS approach as described\n   * by Jukka Jylnki in his survey: \"A Thousand Ways to Pack the Bin - A\n   * Practical Approach to Two-Dimensional Rectangle Bin Packing.\".\n   *\n   * This algorithm is intentionally separated from the rest of the codebase,\n   * because it is it's own library with a different copyright than the rest of\n   * the software. It's also MIT licensed so no worries there. This is intended\n   * to be used as Muuri's default layout algorithm and goes hand in hand with\n   * Muuri's core development.\n   *\n   * @private\n   * @param {Item[]} items\n   * @param {Number} width\n   * @param {Number} height\n   * @param {Object} options\n   * @param {Boolean} [options.fillGaps=false]\n   * @param {Boolean} [options.horizontal=false]\n   * @param {Boolean} [options.alignRight=false]\n   * @param {Boolean} [options.alignBottom=false]\n   * @returns {LayoutData}\n   */\n  function muuriLayout(items, width, height, options) {\n\n    var fillGaps = !!options.fillGaps;\n    var isHorizontal = !!options.horizontal;\n    var alignRight = !!options.alignRight;\n    var alignBottom = !!options.alignBottom;\n    var rounding = !!options.rounding;\n    var layout = {\n      slots: {},\n      width: isHorizontal ? 0 : (rounding ? Math.round(width) : width),\n      height: !isHorizontal ? 0 : (rounding ? Math.round(height) : height),\n      setWidth: isHorizontal,\n      setHeight: !isHorizontal\n    };\n    var freeSlots = [];\n    var slotIds;\n    var slotData;\n    var slot;\n    var item;\n    var itemWidth;\n    var itemHeight;\n    var i;\n\n    // No need to go further if items do not exist.\n    if (!items.length) {\n      return layout;\n    }\n\n    // Find slots for items.\n    for (i = 0; i < items.length; i++) {\n      item = items[i];\n      itemWidth = item._width + item._margin.left + item._margin.right;\n      itemHeight = item._height + item._margin.top + item._margin.bottom;\n      if (rounding) {\n        itemWidth = Math.round(itemWidth);\n        itemHeight = Math.round(itemHeight);\n      }\n      slotData = muuriLayout.getSlot(layout, freeSlots, itemWidth, itemHeight, !isHorizontal, fillGaps);\n      slot = slotData[0];\n      freeSlots = slotData[1];\n      if (isHorizontal) {\n        layout.width = Math.max(layout.width, slot.left + slot.width);\n      }\n      else {\n        layout.height = Math.max(layout.height, slot.top + slot.height);\n      }\n      layout.slots[item._id] = slot;\n    }\n\n    // If the alignment is set to right or bottom, we need to adjust the\n    // results.\n    if (alignRight || alignBottom) {\n      slotIds = Object.keys(layout.slots);\n      for (i = 0; i < slotIds.length; i++) {\n        slot = layout.slots[slotIds[i]];\n        if (alignRight) {\n          slot.left = layout.width - (slot.left + slot.width);\n        }\n        if (alignBottom) {\n          slot.top = layout.height - (slot.top + slot.height);\n        }\n      }\n    }\n\n    return layout;\n\n  }\n\n  /**\n   * Calculate position for the layout item. Returns the left and top position\n   * of the item in pixels.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Layout} layout\n   * @param {Array} slots\n   * @param {Number} itemWidth\n   * @param {Number} itemHeight\n   * @param {Boolean} vertical\n   * @param {Boolean} fillGaps\n   * @returns {Array}\n   */\n  muuriLayout.getSlot = function (layout, slots, itemWidth, itemHeight, vertical, fillGaps) {\n\n    var leeway = 0.001;\n    var newSlots = [];\n    var item = {\n      left: null,\n      top: null,\n      width: itemWidth,\n      height: itemHeight\n    };\n    var slot;\n    var potentialSlots;\n    var ignoreCurrentSlots;\n    var i;\n    var ii;\n\n    // Try to find a slot for the item.\n    for (i = 0; i < slots.length; i++) {\n      slot = slots[i];\n      if (item.width <= (slot.width + leeway) && item.height <= (slot.height + leeway)) {\n        item.left = slot.left;\n        item.top = slot.top;\n        break;\n      }\n    }\n\n    // If no slot was found for the item.\n    if (item.left === null) {\n\n      // Position the item in to the bottom left (vertical mode) or top right\n      // (horizontal mode) of the grid.\n      item.left = vertical ? 0 : layout.width;\n      item.top = vertical ? layout.height : 0;\n\n      // If gaps don't needs filling do not add any current slots to the new\n      // slots array.\n      if (!fillGaps) {\n        ignoreCurrentSlots = true;\n      }\n\n    }\n\n    // In vertical mode, if the item's bottom overlaps the grid's bottom.\n    if (vertical && (item.top + item.height) > layout.height) {\n\n      // If item is not aligned to the left edge, create a new slot.\n      if (item.left > 0) {\n        newSlots.push({\n          left: 0,\n          top: layout.height,\n          width: item.left,\n          height: Infinity\n        });\n      }\n\n      // If item is not aligned to the right edge, create a new slot.\n      if ((item.left + item.width) < layout.width) {\n        newSlots.push({\n          left: item.left + item.width,\n          top: layout.height,\n          width: layout.width - item.left - item.width,\n          height: Infinity\n        });\n      }\n\n      // Update grid height.\n      layout.height = item.top + item.height;\n\n    }\n\n    // In horizontal mode, if the item's right overlaps the grid's right edge.\n    if (!vertical && (item.left + item.width) > layout.width) {\n\n      // If item is not aligned to the top, create a new slot.\n      if (item.top > 0) {\n        newSlots.push({\n          left: layout.width,\n          top: 0,\n          width: Infinity,\n          height: item.top\n        });\n      }\n\n      // If item is not aligned to the bottom, create a new slot.\n      if ((item.top + item.height) < layout.height) {\n        newSlots.push({\n          left: layout.width,\n          top: item.top + item.height,\n          width: Infinity,\n          height: layout.height - item.top - item.height\n        });\n      }\n\n      // Update grid width.\n      layout.width = item.left + item.width;\n\n    }\n\n    // Clean up the current slots making sure there are no old slots that\n    // overlap with the item. If an old slot overlaps with the item, split it\n    // into smaller slots if necessary.\n    for (i = fillGaps ? 0 : ignoreCurrentSlots ? slots.length : i; i < slots.length; i++) {\n      potentialSlots = muuriLayout.splitRect(slots[i], item);\n      for (ii = 0; ii < potentialSlots.length; ii++) {\n        slot = potentialSlots[ii];\n        // Let's make sure here that we have a big enough slot\n        // (width/height > 0.49px) and also let's make sure that the slot is\n        // within the boundaries of the grid.\n        if (slot.width > 0.49 && slot.height > 0.49 && ((vertical && slot.top < layout.height) || (!vertical && slot.left < layout.width))) {\n          newSlots.push(slot);\n        }\n      }\n    }\n\n    // Sanitize new slots.\n    if (newSlots.length) {\n      newSlots = muuriLayout.purgeRects(newSlots).sort(vertical ? muuriLayout.sortRectsTopLeft : muuriLayout.sortRectsLeftTop);\n    }\n\n    // Return the item and updated slots data.\n    return [item, newSlots];\n\n  };\n\n  /**\n   * Punch a hole into a rectangle and split the remaining area into smaller\n   * rectangles (4 at max).\n   *\n   * @private\n   * @param {Rectangle} rect\n   * @param {Rectangle} hole\n   * returns {Rectangle[]}\n   */\n  muuriLayout.splitRect = function (rect, hole) {\n\n    var ret = [];\n\n    // If the rect does not overlap with the hole add rect to the return data as\n    // is.\n    if (!muuriLayout.doRectsOverlap(rect, hole)) {\n      return [{\n        left: rect.left,\n        top: rect.top,\n        width: rect.width,\n        height: rect.height\n      }];\n    }\n\n    // Left split.\n    if (rect.left < hole.left) {\n      ret.push({\n        left: rect.left,\n        top: rect.top,\n        width: hole.left - rect.left,\n        height: rect.height\n      });\n    }\n\n    // Right split.\n    if ((rect.left + rect.width) > (hole.left + hole.width)) {\n      ret.push({\n        left: hole.left + hole.width,\n        top: rect.top,\n        width: (rect.left + rect.width) - (hole.left + hole.width),\n        height: rect.height\n      });\n    }\n\n    // Top split.\n    if (rect.top < hole.top) {\n      ret.push({\n        left: rect.left,\n        top: rect.top,\n        width: rect.width,\n        height: hole.top - rect.top\n      });\n    }\n\n    // Bottom split.\n    if ((rect.top + rect.height) > (hole.top + hole.height)) {\n      ret.push({\n        left: rect.left,\n        top: hole.top + hole.height,\n        width: rect.width,\n        height: (rect.top + rect.height) - (hole.top + hole.height)\n      });\n    }\n\n    return ret;\n\n  };\n\n  /**\n   * Check if two rectangles overlap.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Boolean}\n   */\n  muuriLayout.doRectsOverlap = function (a, b) {\n\n    return !((a.left + a.width) <= b.left || (b.left + b.width) <= a.left || (a.top + a.height) <= b.top || (b.top + b.height) <= a.top);\n\n  };\n\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Boolean}\n   */\n  muuriLayout.isRectWithinRect = function (a, b) {\n\n    return a.left >= b.left && a.top >= b.top && (a.left + a.width) <= (b.left + b.width) && (a.top + a.height) <= (b.top + b.height);\n\n  };\n\n  /**\n   * Loops through an array of rectangles and removes all that are fully within\n   * another rectangle in the array.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle[]} rects\n   * @returns {Rectangle[]}\n   */\n  muuriLayout.purgeRects = function (rects) {\n\n    var i = rects.length;\n    var ii;\n    var rectA;\n    var rectB;\n\n    while (i--) {\n      rectA = rects[i];\n      ii = rects.length;\n      while (ii--) {\n        rectB = rects[ii];\n        if (i !== ii && muuriLayout.isRectWithinRect(rectA, rectB)) {\n          rects.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    return rects;\n\n  };\n\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   */\n  muuriLayout.sortRectsTopLeft = function (a, b) {\n\n    return a.top - b.top || a.left - b.left;\n\n  };\n\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @private\n   * @memberof muuriLayout\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   */\n  muuriLayout.sortRectsLeftTop = function (a, b) {\n\n    return a.left - b.left || a.top - b.top;\n\n  };\n\n  /**\n   * Type definitions\n   * ****************\n   */\n\n  /* eslint-disable */\n  /**\n   * The values by which multiple grid items can be queried. An html element or\n   * an array of HTML elements. Item or an array of items. Node list, live or\n   * static. Number (index) or a list of numbers (indices).\n   *\n   * @typedef {(HTMLElement|HTMLElement[]|Item|Item[]|NodeList|Number|Number[])} GridMultiItemQuery\n   */\n  /* eslint-enable */\n\n  /**\n   * The values by which a single grid item can be queried. An html element, an\n   * item instance or a number (index).\n   *\n   * @typedef {(HTMLElement|Item|Number)} GridSingleItemQuery\n   */\n\n  /**\n   * The grid item's state, a string. Accepted values are: \"active\", \"inactive\",\n   * \"visible\", \"hidden\", \"showing\", \"hiding\", \"positioning\", \"dragging\",\n   * \"releasing\" and \"migrating\".\n   *\n   * @typedef {String} GridItemState\n   */\n\n  /**\n   * The data that is required to orchestrate a sort action during drag.\n   *\n   * @typedef {Object} DragSortCommand\n   * @param {String} action\n   *   - \"move\" or \"swap\".\n   * @param {Number} index\n   *   - target index.\n   * @param {?Grid} [grid=null]\n   *   - target grid.\n   */\n\n  /**\n   * A rectangle is an object with width, height and offset (left and top) data.\n   *\n   * @typedef {Object} Rectangle\n   * @property {Number} width\n   * @property {Number} height\n   * @property {Number} left\n   * @property {Number} top\n   */\n\n  /**\n   * Layout data for the layout instance.\n   *\n   * @typedef {Object} LayoutData\n   * @property {Object} slots\n   * @property {Number} width\n   * @property {Number} height\n   * @property {Boolean} setWidth\n   * @property {Boolean} setHeight\n   */\n\n  /**\n   * @callback LayoutCallback\n   * @param {Boolean} isAborted\n   *   - Was the layout procedure aborted?\n   * @param {Item[]} items\n   *   - The items that were attempted to be positioned.\n   */\n\n  /**\n   * @callback ShowCallback\n   * @param {Item[]} items\n   *   - The items that were successfully shown without interruptions.\n   */\n\n  /**\n   * @callback HideCallback\n   * @param {Item[]} items\n   *   - The items that were successfully hidden without interruptions.\n   */\n\n  /**\n   * @callback FilterCallback\n   * @param {Item[]} shownItems\n   *   - The items that were shown.\n   * @param {Item[]} hiddenItems\n   *   - The items that were hidden.\n   */\n\n  /**\n   * Init\n   */\n\n  return Grid;\n\n}));\n\n\n//# sourceURL=webpack://PermutationTaskUI/./node_modules/muuri/muuri.js?");

/***/ }),

/***/ "./src/index.jsx":
/*!***********************!*\
  !*** ./src/index.jsx ***!
  \***********************/
/*! exports provided: generate_permutation_list, generate_permutation_list_with */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generate_permutation_list\", function() { return generate_permutation_list; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generate_permutation_list_with\", function() { return generate_permutation_list_with; });\n/* harmony import */ var muuri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muuri */ \"./node_modules/muuri/muuri.js\");\n/* harmony import */ var muuri__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(muuri__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nconst itemFactory = (elemId, text) => {\n\t// TODO: Change classes prefix to avoid conflicts\n\tconst item = document.createElement('div')\n\titem.setAttribute('class', 'board-item')\n\t\n\tconst itemContent = document.createElement('div')\n\titemContent.setAttribute('id', elemId)\n\titemContent.setAttribute('class', 'board-item-content')\n\titemContent.innerHTML = text;\n\titem.appendChild(itemContent)\n\n\treturn item\n}\n\nvar columnGrids = [];\n\nfunction generate_permutation_list(nodeName, dragReleaseListener) {\n\t// Taken from kanban\n\tvar grid = new muuri__WEBPACK_IMPORTED_MODULE_0___default.a(nodeName, {\n\t\titems: '*',\n\t\tlayoutDuration: 400,\n\t\tlayoutEasing: 'ease',\n\t\tdragEnabled: true,\n\t\tdragSort: function () {\n\t\t\treturn columnGrids;\n\t\t},\n\t\tdragSortInterval: 0,\n\t\tdragContainer: document.body,\n\t\tdragReleaseDuration: 400,\n\t\tdragReleaseEasing: 'ease'\n\t})\n\t.on('dragStart', function (item) {\n\t\t// Let's set fixed widht/height to the dragged item\n\t\t// so that it does not stretch unwillingly when\n\t\t// it's appended to the document body for the\n\t\t// duration of the drag.\n\t\titem.getElement().style.width = item.getWidth() + 'px';\n\t\titem.getElement().style.height = item.getHeight() + 'px';\n\t})\n\t.on('dragReleaseEnd', function (item) {\n\t\t// Let's remove the fixed width/height from the\n\t\t// dragged item now that it is back in a grid\n\t\t// column and can freely adjust to it's\n\t\t// surroundings.\n\t\titem.getElement().style.width = '';\n\t\titem.getElement().style.height = '';\n\t\t// Just in case, let's refresh the dimensions of all items\n\t\t// in case dragging the item caused some other items to\n\t\t// be different size.\n\t\tcolumnGrids.forEach(function (grid) {\n\t\t\tgrid.refreshItems();\n\t\t});\n\t\t// Notify change of items order\n\t\tdragReleaseListener();\n\t})\n\t.on('layoutStart', function () {\n\t\t// Let's keep the board grid up to date with the\n\t\t// dimensions changes of column grids.\n\t});\n\n\tcolumnGrids.push(grid);\n}\n\nfunction generate_permutation_list_with(elemsId, elems, nodeName, dragReleaseListener) {\n\tconst elemsPack = elemsId.map(function(elemId, i) {return [elemId, elems[i]]})\n\telemsPack.map(textPack => document.querySelector(nodeName).appendChild(itemFactory(textPack[0], textPack[1])))\n\n\tgenerate_permutation_list(nodeName, dragReleaseListener);\n}\n\n// generate_permutation_list([Array(110).join(' C-C C+C ') + ';','D','A','B'], '.board-column-content');\n\n\n//# sourceURL=webpack://PermutationTaskUI/./src/index.jsx?");

/***/ })

/******/ });